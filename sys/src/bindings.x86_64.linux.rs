/* automatically generated by rust-bindgen 0.60.1 */

#![allow(nonstandard_style)]

pub const LIB3MF_VERSION_MAJOR: u32 = 2;
pub const LIB3MF_VERSION_MINOR: u32 = 2;
pub const LIB3MF_VERSION_MICRO: u32 = 0;
pub const LIB3MF_VERSION_PRERELEASEINFO: &[u8; 1usize] = b"\0";
pub const LIB3MF_VERSION_BUILDINFO: &[u8; 1usize] = b"\0";
pub const LIB3MF_SUCCESS: u32 = 0;
pub const LIB3MF_ERROR_NOTIMPLEMENTED: u32 = 1;
pub const LIB3MF_ERROR_INVALIDPARAM: u32 = 2;
pub const LIB3MF_ERROR_INVALIDCAST: u32 = 3;
pub const LIB3MF_ERROR_BUFFERTOOSMALL: u32 = 4;
pub const LIB3MF_ERROR_GENERICEXCEPTION: u32 = 5;
pub const LIB3MF_ERROR_COULDNOTLOADLIBRARY: u32 = 6;
pub const LIB3MF_ERROR_COULDNOTFINDLIBRARYEXPORT: u32 = 7;
pub const LIB3MF_ERROR_INCOMPATIBLEBINARYVERSION: u32 = 8;
pub const LIB3MF_ERROR_CALCULATIONABORTED: u32 = 10;
pub const LIB3MF_ERROR_SHOULDNOTBECALLED: u32 = 11;
pub const LIB3MF_ERROR_READERCLASSUNKNOWN: u32 = 100;
pub const LIB3MF_ERROR_WRITERCLASSUNKNOWN: u32 = 101;
pub const LIB3MF_ERROR_ITERATORINVALIDINDEX: u32 = 102;
pub const LIB3MF_ERROR_INVALIDMODELRESOURCE: u32 = 103;
pub const LIB3MF_ERROR_RESOURCENOTFOUND: u32 = 104;
pub const LIB3MF_ERROR_INVALIDMODEL: u32 = 105;
pub const LIB3MF_ERROR_INVALIDOBJECT: u32 = 106;
pub const LIB3MF_ERROR_INVALIDMESHOBJECT: u32 = 107;
pub const LIB3MF_ERROR_INVALIDCOMPONENTSOBJECT: u32 = 108;
pub const LIB3MF_ERROR_INVALIDCOMPONENT: u32 = 109;
pub const LIB3MF_ERROR_INVALIDBUILDITEM: u32 = 110;
pub const LIB3MF_ERROR_INVALIDBASEMATERIALGROUP: u32 = 111;
pub const LIB3MF_ERROR_INVALIDSLICESTACKRESOURCE: u32 = 112;
pub const LIB3MF_ERROR_INVALIDTEXTURERESOURCE: u32 = 113;
pub const LIB3MF_ERROR_INVALIDCOLORGROUP: u32 = 114;
pub const LIB3MF_ERROR_INVALIDTEXTURE2DGROUP: u32 = 115;
pub const LIB3MF_ERROR_INVALIDCOMPOSITEMATERIALS: u32 = 116;
pub const LIB3MF_ERROR_INVALIDMULTIPROPERTYGROUP: u32 = 117;
pub const LIB3MF_ERROR_INVALIDRESOURCEINDEX: u32 = 120;
pub const LIB3MF_ERROR_ATTACHMENTNOTFOUND: u32 = 121;
pub const LIB3MF_ERROR_FORBIDDENCYCLICREFERENCE: u32 = 130;
pub const LIB3MF_ERROR_INVALIDATTACHMENTSTREAM: u32 = 131;
pub const LIB3MF_ERROR_INVALIDPROPERTYCOUNT: u32 = 132;
pub const LIB3MF_ERROR_UNKOWNPROGRESSIDENTIFIER: u32 = 140;
pub const LIB3MF_ERROR_ELEMENTCOUNTEXCEEDSLIMIT: u32 = 141;
pub const LIB3MF_ERROR_BEAMLATTICE_INVALID_OBJECTTYPE: u32 = 2000;
pub const LIB3MF_ERROR_INVALIDKEYSTORE: u32 = 3000;
pub const LIB3MF_ERROR_INVALIDKEYSTORECONSUMER: u32 = 3001;
pub const LIB3MF_ERROR_KEYSTORECONSUMERNOTFOUND: u32 = 3002;
pub const LIB3MF_ERROR_KEYSTORERESOURCEDATANOTFOUND: u32 = 3003;
pub const LIB3MF_ERROR_SECURECONTEXTNOTREGISTERED: u32 = 3004;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type Lib3MF_uint8 = u8;
pub type Lib3MF_uint32 = u32;
pub type Lib3MF_uint64 = u64;
pub type Lib3MF_int32 = i32;
pub type Lib3MF_single = f32;
pub type Lib3MF_double = f64;
#[doc = "General type definitions"]
pub type Lib3MFResult = Lib3MF_int32;
pub type Lib3MFHandle = *mut ::std::os::raw::c_void;
pub type Lib3MF_pvoid = *mut ::std::os::raw::c_void;
#[doc = "Declaration of handle classes"]
pub type Lib3MF_Base = Lib3MFHandle;
pub type Lib3MF_Writer = Lib3MFHandle;
pub type Lib3MF_Reader = Lib3MFHandle;
pub type Lib3MF_PackagePart = Lib3MFHandle;
pub type Lib3MF_Resource = Lib3MFHandle;
pub type Lib3MF_ResourceIterator = Lib3MFHandle;
pub type Lib3MF_SliceStackIterator = Lib3MFHandle;
pub type Lib3MF_ObjectIterator = Lib3MFHandle;
pub type Lib3MF_MeshObjectIterator = Lib3MFHandle;
pub type Lib3MF_ComponentsObjectIterator = Lib3MFHandle;
pub type Lib3MF_Texture2DIterator = Lib3MFHandle;
pub type Lib3MF_BaseMaterialGroupIterator = Lib3MFHandle;
pub type Lib3MF_ColorGroupIterator = Lib3MFHandle;
pub type Lib3MF_Texture2DGroupIterator = Lib3MFHandle;
pub type Lib3MF_CompositeMaterialsIterator = Lib3MFHandle;
pub type Lib3MF_MultiPropertyGroupIterator = Lib3MFHandle;
pub type Lib3MF_MetaData = Lib3MFHandle;
pub type Lib3MF_MetaDataGroup = Lib3MFHandle;
pub type Lib3MF_Object = Lib3MFHandle;
pub type Lib3MF_MeshObject = Lib3MFHandle;
pub type Lib3MF_BeamLattice = Lib3MFHandle;
pub type Lib3MF_Component = Lib3MFHandle;
pub type Lib3MF_ComponentsObject = Lib3MFHandle;
pub type Lib3MF_BeamSet = Lib3MFHandle;
pub type Lib3MF_BaseMaterialGroup = Lib3MFHandle;
pub type Lib3MF_ColorGroup = Lib3MFHandle;
pub type Lib3MF_Texture2DGroup = Lib3MFHandle;
pub type Lib3MF_CompositeMaterials = Lib3MFHandle;
pub type Lib3MF_MultiPropertyGroup = Lib3MFHandle;
pub type Lib3MF_Attachment = Lib3MFHandle;
pub type Lib3MF_Texture2D = Lib3MFHandle;
pub type Lib3MF_BuildItem = Lib3MFHandle;
pub type Lib3MF_BuildItemIterator = Lib3MFHandle;
pub type Lib3MF_Slice = Lib3MFHandle;
pub type Lib3MF_SliceStack = Lib3MFHandle;
pub type Lib3MF_Consumer = Lib3MFHandle;
pub type Lib3MF_AccessRight = Lib3MFHandle;
pub type Lib3MF_ContentEncryptionParams = Lib3MFHandle;
pub type Lib3MF_ResourceData = Lib3MFHandle;
pub type Lib3MF_ResourceDataGroup = Lib3MFHandle;
pub type Lib3MF_KeyStore = Lib3MFHandle;
pub type Lib3MF_Model = Lib3MFHandle;
pub const eLib3MFPropertyType_ePropertyTypeNoPropertyType: eLib3MFPropertyType = 0;
pub const eLib3MFPropertyType_ePropertyTypeBaseMaterial: eLib3MFPropertyType = 1;
pub const eLib3MFPropertyType_ePropertyTypeTexCoord: eLib3MFPropertyType = 2;
pub const eLib3MFPropertyType_ePropertyTypeColors: eLib3MFPropertyType = 3;
pub const eLib3MFPropertyType_ePropertyTypeComposite: eLib3MFPropertyType = 4;
pub const eLib3MFPropertyType_ePropertyTypeMulti: eLib3MFPropertyType = 5;
#[doc = "Declaration of enums"]
pub type eLib3MFPropertyType = ::std::os::raw::c_uint;
pub const eLib3MFSlicesMeshResolution_eSlicesMeshResolutionFullres: eLib3MFSlicesMeshResolution = 0;
pub const eLib3MFSlicesMeshResolution_eSlicesMeshResolutionLowres: eLib3MFSlicesMeshResolution = 1;
pub type eLib3MFSlicesMeshResolution = ::std::os::raw::c_uint;
pub const eLib3MFModelUnit_eModelUnitMicroMeter: eLib3MFModelUnit = 0;
pub const eLib3MFModelUnit_eModelUnitMilliMeter: eLib3MFModelUnit = 1;
pub const eLib3MFModelUnit_eModelUnitCentiMeter: eLib3MFModelUnit = 2;
pub const eLib3MFModelUnit_eModelUnitInch: eLib3MFModelUnit = 3;
pub const eLib3MFModelUnit_eModelUnitFoot: eLib3MFModelUnit = 4;
pub const eLib3MFModelUnit_eModelUnitMeter: eLib3MFModelUnit = 5;
pub type eLib3MFModelUnit = ::std::os::raw::c_uint;
pub const eLib3MFObjectType_eObjectTypeOther: eLib3MFObjectType = 0;
pub const eLib3MFObjectType_eObjectTypeModel: eLib3MFObjectType = 1;
pub const eLib3MFObjectType_eObjectTypeSupport: eLib3MFObjectType = 2;
pub const eLib3MFObjectType_eObjectTypeSolidSupport: eLib3MFObjectType = 3;
pub type eLib3MFObjectType = ::std::os::raw::c_uint;
pub const eLib3MFTextureType_eTextureTypeUnknown: eLib3MFTextureType = 0;
pub const eLib3MFTextureType_eTextureTypePNG: eLib3MFTextureType = 1;
pub const eLib3MFTextureType_eTextureTypeJPEG: eLib3MFTextureType = 2;
pub type eLib3MFTextureType = ::std::os::raw::c_uint;
pub const eLib3MFTextureTileStyle_eTextureTileStyleWrap: eLib3MFTextureTileStyle = 0;
pub const eLib3MFTextureTileStyle_eTextureTileStyleMirror: eLib3MFTextureTileStyle = 1;
pub const eLib3MFTextureTileStyle_eTextureTileStyleClamp: eLib3MFTextureTileStyle = 2;
pub const eLib3MFTextureTileStyle_eTextureTileStyleNoTileStyle: eLib3MFTextureTileStyle = 3;
pub type eLib3MFTextureTileStyle = ::std::os::raw::c_uint;
pub const eLib3MFTextureFilter_eTextureFilterAuto: eLib3MFTextureFilter = 0;
pub const eLib3MFTextureFilter_eTextureFilterLinear: eLib3MFTextureFilter = 1;
pub const eLib3MFTextureFilter_eTextureFilterNearest: eLib3MFTextureFilter = 2;
pub type eLib3MFTextureFilter = ::std::os::raw::c_uint;
pub const eLib3MFBeamLatticeCapMode_eBeamLatticeCapModeSphere: eLib3MFBeamLatticeCapMode = 0;
pub const eLib3MFBeamLatticeCapMode_eBeamLatticeCapModeHemiSphere: eLib3MFBeamLatticeCapMode = 1;
pub const eLib3MFBeamLatticeCapMode_eBeamLatticeCapModeButt: eLib3MFBeamLatticeCapMode = 2;
pub type eLib3MFBeamLatticeCapMode = ::std::os::raw::c_uint;
pub const eLib3MFBeamLatticeClipMode_eBeamLatticeClipModeNoClipMode: eLib3MFBeamLatticeClipMode = 0;
pub const eLib3MFBeamLatticeClipMode_eBeamLatticeClipModeInside: eLib3MFBeamLatticeClipMode = 1;
pub const eLib3MFBeamLatticeClipMode_eBeamLatticeClipModeOutside: eLib3MFBeamLatticeClipMode = 2;
pub type eLib3MFBeamLatticeClipMode = ::std::os::raw::c_uint;
pub const eLib3MFBeamLatticeBallMode_eBeamLatticeBallModeNone: eLib3MFBeamLatticeBallMode = 0;
pub const eLib3MFBeamLatticeBallMode_eBeamLatticeBallModeMixed: eLib3MFBeamLatticeBallMode = 1;
pub const eLib3MFBeamLatticeBallMode_eBeamLatticeBallModeAll: eLib3MFBeamLatticeBallMode = 2;
pub type eLib3MFBeamLatticeBallMode = ::std::os::raw::c_uint;
pub const eLib3MFProgressIdentifier_eProgressIdentifierQUERYCANCELED: eLib3MFProgressIdentifier = 0;
pub const eLib3MFProgressIdentifier_eProgressIdentifierDONE: eLib3MFProgressIdentifier = 1;
pub const eLib3MFProgressIdentifier_eProgressIdentifierCLEANUP: eLib3MFProgressIdentifier = 2;
pub const eLib3MFProgressIdentifier_eProgressIdentifierREADSTREAM: eLib3MFProgressIdentifier = 3;
pub const eLib3MFProgressIdentifier_eProgressIdentifierEXTRACTOPCPACKAGE:
    eLib3MFProgressIdentifier = 4;
pub const eLib3MFProgressIdentifier_eProgressIdentifierREADNONROOTMODELS:
    eLib3MFProgressIdentifier = 5;
pub const eLib3MFProgressIdentifier_eProgressIdentifierREADROOTMODEL: eLib3MFProgressIdentifier = 6;
pub const eLib3MFProgressIdentifier_eProgressIdentifierREADRESOURCES: eLib3MFProgressIdentifier = 7;
pub const eLib3MFProgressIdentifier_eProgressIdentifierREADMESH: eLib3MFProgressIdentifier = 8;
pub const eLib3MFProgressIdentifier_eProgressIdentifierREADSLICES: eLib3MFProgressIdentifier = 9;
pub const eLib3MFProgressIdentifier_eProgressIdentifierREADBUILD: eLib3MFProgressIdentifier = 10;
pub const eLib3MFProgressIdentifier_eProgressIdentifierREADCUSTOMATTACHMENT:
    eLib3MFProgressIdentifier = 11;
pub const eLib3MFProgressIdentifier_eProgressIdentifierREADTEXTURETACHMENTS:
    eLib3MFProgressIdentifier = 12;
pub const eLib3MFProgressIdentifier_eProgressIdentifierCREATEOPCPACKAGE: eLib3MFProgressIdentifier =
    13;
pub const eLib3MFProgressIdentifier_eProgressIdentifierWRITEMODELSTOSTREAM:
    eLib3MFProgressIdentifier = 14;
pub const eLib3MFProgressIdentifier_eProgressIdentifierWRITEROOTMODEL: eLib3MFProgressIdentifier =
    15;
pub const eLib3MFProgressIdentifier_eProgressIdentifierWRITENONROOTMODELS:
    eLib3MFProgressIdentifier = 16;
pub const eLib3MFProgressIdentifier_eProgressIdentifierWRITEATTACHMENTS: eLib3MFProgressIdentifier =
    17;
pub const eLib3MFProgressIdentifier_eProgressIdentifierWRITECONTENTTYPES:
    eLib3MFProgressIdentifier = 18;
pub const eLib3MFProgressIdentifier_eProgressIdentifierWRITENOBJECTS: eLib3MFProgressIdentifier =
    19;
pub const eLib3MFProgressIdentifier_eProgressIdentifierWRITENODES: eLib3MFProgressIdentifier = 20;
pub const eLib3MFProgressIdentifier_eProgressIdentifierWRITETRIANGLES: eLib3MFProgressIdentifier =
    21;
pub const eLib3MFProgressIdentifier_eProgressIdentifierWRITESLICES: eLib3MFProgressIdentifier = 22;
pub const eLib3MFProgressIdentifier_eProgressIdentifierWRITEKEYSTORE: eLib3MFProgressIdentifier =
    23;
pub type eLib3MFProgressIdentifier = ::std::os::raw::c_uint;
pub const eLib3MFBlendMethod_eBlendMethodNoBlendMethod: eLib3MFBlendMethod = 0;
pub const eLib3MFBlendMethod_eBlendMethodMix: eLib3MFBlendMethod = 1;
pub const eLib3MFBlendMethod_eBlendMethodMultiply: eLib3MFBlendMethod = 2;
pub type eLib3MFBlendMethod = ::std::os::raw::c_uint;
pub const eLib3MFEncryptionAlgorithm_eEncryptionAlgorithmAES256_GCM: eLib3MFEncryptionAlgorithm = 1;
pub type eLib3MFEncryptionAlgorithm = ::std::os::raw::c_uint;
pub const eLib3MFWrappingAlgorithm_eWrappingAlgorithmRSA_OAEP: eLib3MFWrappingAlgorithm = 0;
pub type eLib3MFWrappingAlgorithm = ::std::os::raw::c_uint;
pub const eLib3MFMgfAlgorithm_eMgfAlgorithmMGF1_SHA1: eLib3MFMgfAlgorithm = 160;
pub const eLib3MFMgfAlgorithm_eMgfAlgorithmMGF1_SHA224: eLib3MFMgfAlgorithm = 224;
pub const eLib3MFMgfAlgorithm_eMgfAlgorithmMGF1_SHA256: eLib3MFMgfAlgorithm = 256;
pub const eLib3MFMgfAlgorithm_eMgfAlgorithmMGF1_SHA384: eLib3MFMgfAlgorithm = 384;
pub const eLib3MFMgfAlgorithm_eMgfAlgorithmMGF1_SHA512: eLib3MFMgfAlgorithm = 512;
pub type eLib3MFMgfAlgorithm = ::std::os::raw::c_uint;
pub const eLib3MFDigestMethod_eDigestMethodSHA1: eLib3MFDigestMethod = 160;
pub const eLib3MFDigestMethod_eDigestMethodSHA256: eLib3MFDigestMethod = 256;
pub type eLib3MFDigestMethod = ::std::os::raw::c_uint;
pub const eLib3MFCompression_eCompressionNoCompression: eLib3MFCompression = 0;
pub const eLib3MFCompression_eCompressionDeflate: eLib3MFCompression = 1;
pub type eLib3MFCompression = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union structEnumLib3MFBeamLatticeCapMode {
    pub m_enum: eLib3MFBeamLatticeCapMode,
    pub m_code: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_structEnumLib3MFBeamLatticeCapMode() {
    assert_eq!(
        ::std::mem::size_of::<structEnumLib3MFBeamLatticeCapMode>(),
        4usize,
        concat!("Size of: ", stringify!(structEnumLib3MFBeamLatticeCapMode))
    );
    assert_eq!(
        ::std::mem::align_of::<structEnumLib3MFBeamLatticeCapMode>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(structEnumLib3MFBeamLatticeCapMode)
        )
    );
    fn test_field_m_enum() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<structEnumLib3MFBeamLatticeCapMode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_enum) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(structEnumLib3MFBeamLatticeCapMode),
                "::",
                stringify!(m_enum)
            )
        );
    }
    test_field_m_enum();
    fn test_field_m_code() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<structEnumLib3MFBeamLatticeCapMode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_code) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(structEnumLib3MFBeamLatticeCapMode),
                "::",
                stringify!(m_code)
            )
        );
    }
    test_field_m_code();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union structEnumLib3MFBlendMethod {
    pub m_enum: eLib3MFBlendMethod,
    pub m_code: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_structEnumLib3MFBlendMethod() {
    assert_eq!(
        ::std::mem::size_of::<structEnumLib3MFBlendMethod>(),
        4usize,
        concat!("Size of: ", stringify!(structEnumLib3MFBlendMethod))
    );
    assert_eq!(
        ::std::mem::align_of::<structEnumLib3MFBlendMethod>(),
        4usize,
        concat!("Alignment of ", stringify!(structEnumLib3MFBlendMethod))
    );
    fn test_field_m_enum() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<structEnumLib3MFBlendMethod>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_enum) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(structEnumLib3MFBlendMethod),
                "::",
                stringify!(m_enum)
            )
        );
    }
    test_field_m_enum();
    fn test_field_m_code() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<structEnumLib3MFBlendMethod>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_code) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(structEnumLib3MFBlendMethod),
                "::",
                stringify!(m_code)
            )
        );
    }
    test_field_m_code();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sLib3MFTriangle {
    pub m_Indices: [Lib3MF_uint32; 3usize],
}
#[test]
fn bindgen_test_layout_sLib3MFTriangle() {
    assert_eq!(
        ::std::mem::size_of::<sLib3MFTriangle>(),
        12usize,
        concat!("Size of: ", stringify!(sLib3MFTriangle))
    );
    assert_eq!(
        ::std::mem::align_of::<sLib3MFTriangle>(),
        1usize,
        concat!("Alignment of ", stringify!(sLib3MFTriangle))
    );
    fn test_field_m_Indices() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sLib3MFTriangle>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_Indices) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sLib3MFTriangle),
                "::",
                stringify!(m_Indices)
            )
        );
    }
    test_field_m_Indices();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sLib3MFTriangleProperties {
    pub m_ResourceID: Lib3MF_uint32,
    pub m_PropertyIDs: [Lib3MF_uint32; 3usize],
}
#[test]
fn bindgen_test_layout_sLib3MFTriangleProperties() {
    assert_eq!(
        ::std::mem::size_of::<sLib3MFTriangleProperties>(),
        16usize,
        concat!("Size of: ", stringify!(sLib3MFTriangleProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<sLib3MFTriangleProperties>(),
        1usize,
        concat!("Alignment of ", stringify!(sLib3MFTriangleProperties))
    );
    fn test_field_m_ResourceID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sLib3MFTriangleProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_ResourceID) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sLib3MFTriangleProperties),
                "::",
                stringify!(m_ResourceID)
            )
        );
    }
    test_field_m_ResourceID();
    fn test_field_m_PropertyIDs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sLib3MFTriangleProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_PropertyIDs) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sLib3MFTriangleProperties),
                "::",
                stringify!(m_PropertyIDs)
            )
        );
    }
    test_field_m_PropertyIDs();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sLib3MFPosition {
    pub m_Coordinates: [Lib3MF_single; 3usize],
}
#[test]
fn bindgen_test_layout_sLib3MFPosition() {
    assert_eq!(
        ::std::mem::size_of::<sLib3MFPosition>(),
        12usize,
        concat!("Size of: ", stringify!(sLib3MFPosition))
    );
    assert_eq!(
        ::std::mem::align_of::<sLib3MFPosition>(),
        1usize,
        concat!("Alignment of ", stringify!(sLib3MFPosition))
    );
    fn test_field_m_Coordinates() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sLib3MFPosition>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_Coordinates) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sLib3MFPosition),
                "::",
                stringify!(m_Coordinates)
            )
        );
    }
    test_field_m_Coordinates();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sLib3MFPosition2D {
    pub m_Coordinates: [Lib3MF_single; 2usize],
}
#[test]
fn bindgen_test_layout_sLib3MFPosition2D() {
    assert_eq!(
        ::std::mem::size_of::<sLib3MFPosition2D>(),
        8usize,
        concat!("Size of: ", stringify!(sLib3MFPosition2D))
    );
    assert_eq!(
        ::std::mem::align_of::<sLib3MFPosition2D>(),
        1usize,
        concat!("Alignment of ", stringify!(sLib3MFPosition2D))
    );
    fn test_field_m_Coordinates() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sLib3MFPosition2D>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_Coordinates) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sLib3MFPosition2D),
                "::",
                stringify!(m_Coordinates)
            )
        );
    }
    test_field_m_Coordinates();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sLib3MFCompositeConstituent {
    pub m_PropertyID: Lib3MF_uint32,
    pub m_MixingRatio: Lib3MF_double,
}
#[test]
fn bindgen_test_layout_sLib3MFCompositeConstituent() {
    assert_eq!(
        ::std::mem::size_of::<sLib3MFCompositeConstituent>(),
        12usize,
        concat!("Size of: ", stringify!(sLib3MFCompositeConstituent))
    );
    assert_eq!(
        ::std::mem::align_of::<sLib3MFCompositeConstituent>(),
        1usize,
        concat!("Alignment of ", stringify!(sLib3MFCompositeConstituent))
    );
    fn test_field_m_PropertyID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sLib3MFCompositeConstituent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_PropertyID) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sLib3MFCompositeConstituent),
                "::",
                stringify!(m_PropertyID)
            )
        );
    }
    test_field_m_PropertyID();
    fn test_field_m_MixingRatio() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sLib3MFCompositeConstituent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_MixingRatio) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sLib3MFCompositeConstituent),
                "::",
                stringify!(m_MixingRatio)
            )
        );
    }
    test_field_m_MixingRatio();
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sLib3MFMultiPropertyLayer {
    pub m_ResourceID: Lib3MF_uint32,
    pub m_TheBlendMethod: structEnumLib3MFBlendMethod,
}
#[test]
fn bindgen_test_layout_sLib3MFMultiPropertyLayer() {
    assert_eq!(
        ::std::mem::size_of::<sLib3MFMultiPropertyLayer>(),
        8usize,
        concat!("Size of: ", stringify!(sLib3MFMultiPropertyLayer))
    );
    assert_eq!(
        ::std::mem::align_of::<sLib3MFMultiPropertyLayer>(),
        1usize,
        concat!("Alignment of ", stringify!(sLib3MFMultiPropertyLayer))
    );
    fn test_field_m_ResourceID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sLib3MFMultiPropertyLayer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_ResourceID) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sLib3MFMultiPropertyLayer),
                "::",
                stringify!(m_ResourceID)
            )
        );
    }
    test_field_m_ResourceID();
    fn test_field_m_TheBlendMethod() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sLib3MFMultiPropertyLayer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_TheBlendMethod) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sLib3MFMultiPropertyLayer),
                "::",
                stringify!(m_TheBlendMethod)
            )
        );
    }
    test_field_m_TheBlendMethod();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sLib3MFTex2Coord {
    pub m_U: Lib3MF_double,
    pub m_V: Lib3MF_double,
}
#[test]
fn bindgen_test_layout_sLib3MFTex2Coord() {
    assert_eq!(
        ::std::mem::size_of::<sLib3MFTex2Coord>(),
        16usize,
        concat!("Size of: ", stringify!(sLib3MFTex2Coord))
    );
    assert_eq!(
        ::std::mem::align_of::<sLib3MFTex2Coord>(),
        1usize,
        concat!("Alignment of ", stringify!(sLib3MFTex2Coord))
    );
    fn test_field_m_U() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sLib3MFTex2Coord>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_U) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sLib3MFTex2Coord),
                "::",
                stringify!(m_U)
            )
        );
    }
    test_field_m_U();
    fn test_field_m_V() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sLib3MFTex2Coord>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_V) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sLib3MFTex2Coord),
                "::",
                stringify!(m_V)
            )
        );
    }
    test_field_m_V();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sLib3MFTransform {
    pub m_Fields: [[Lib3MF_single; 3usize]; 4usize],
}
#[test]
fn bindgen_test_layout_sLib3MFTransform() {
    assert_eq!(
        ::std::mem::size_of::<sLib3MFTransform>(),
        48usize,
        concat!("Size of: ", stringify!(sLib3MFTransform))
    );
    assert_eq!(
        ::std::mem::align_of::<sLib3MFTransform>(),
        1usize,
        concat!("Alignment of ", stringify!(sLib3MFTransform))
    );
    fn test_field_m_Fields() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sLib3MFTransform>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_Fields) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sLib3MFTransform),
                "::",
                stringify!(m_Fields)
            )
        );
    }
    test_field_m_Fields();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sLib3MFBox {
    pub m_MinCoordinate: [Lib3MF_single; 3usize],
    pub m_MaxCoordinate: [Lib3MF_single; 3usize],
}
#[test]
fn bindgen_test_layout_sLib3MFBox() {
    assert_eq!(
        ::std::mem::size_of::<sLib3MFBox>(),
        24usize,
        concat!("Size of: ", stringify!(sLib3MFBox))
    );
    assert_eq!(
        ::std::mem::align_of::<sLib3MFBox>(),
        1usize,
        concat!("Alignment of ", stringify!(sLib3MFBox))
    );
    fn test_field_m_MinCoordinate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sLib3MFBox>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_MinCoordinate) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sLib3MFBox),
                "::",
                stringify!(m_MinCoordinate)
            )
        );
    }
    test_field_m_MinCoordinate();
    fn test_field_m_MaxCoordinate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sLib3MFBox>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_MaxCoordinate) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(sLib3MFBox),
                "::",
                stringify!(m_MaxCoordinate)
            )
        );
    }
    test_field_m_MaxCoordinate();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sLib3MFColor {
    pub m_Red: Lib3MF_uint8,
    pub m_Green: Lib3MF_uint8,
    pub m_Blue: Lib3MF_uint8,
    pub m_Alpha: Lib3MF_uint8,
}
#[test]
fn bindgen_test_layout_sLib3MFColor() {
    assert_eq!(
        ::std::mem::size_of::<sLib3MFColor>(),
        4usize,
        concat!("Size of: ", stringify!(sLib3MFColor))
    );
    assert_eq!(
        ::std::mem::align_of::<sLib3MFColor>(),
        1usize,
        concat!("Alignment of ", stringify!(sLib3MFColor))
    );
    fn test_field_m_Red() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sLib3MFColor>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_Red) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sLib3MFColor),
                "::",
                stringify!(m_Red)
            )
        );
    }
    test_field_m_Red();
    fn test_field_m_Green() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sLib3MFColor>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_Green) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(sLib3MFColor),
                "::",
                stringify!(m_Green)
            )
        );
    }
    test_field_m_Green();
    fn test_field_m_Blue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sLib3MFColor>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_Blue) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sLib3MFColor),
                "::",
                stringify!(m_Blue)
            )
        );
    }
    test_field_m_Blue();
    fn test_field_m_Alpha() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sLib3MFColor>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_Alpha) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(sLib3MFColor),
                "::",
                stringify!(m_Alpha)
            )
        );
    }
    test_field_m_Alpha();
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct sLib3MFBeam {
    pub m_Indices: [Lib3MF_uint32; 2usize],
    pub m_Radii: [Lib3MF_double; 2usize],
    pub m_CapModes: [structEnumLib3MFBeamLatticeCapMode; 2usize],
}
#[test]
fn bindgen_test_layout_sLib3MFBeam() {
    assert_eq!(
        ::std::mem::size_of::<sLib3MFBeam>(),
        32usize,
        concat!("Size of: ", stringify!(sLib3MFBeam))
    );
    assert_eq!(
        ::std::mem::align_of::<sLib3MFBeam>(),
        1usize,
        concat!("Alignment of ", stringify!(sLib3MFBeam))
    );
    fn test_field_m_Indices() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sLib3MFBeam>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_Indices) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sLib3MFBeam),
                "::",
                stringify!(m_Indices)
            )
        );
    }
    test_field_m_Indices();
    fn test_field_m_Radii() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sLib3MFBeam>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_Radii) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sLib3MFBeam),
                "::",
                stringify!(m_Radii)
            )
        );
    }
    test_field_m_Radii();
    fn test_field_m_CapModes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sLib3MFBeam>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_CapModes) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(sLib3MFBeam),
                "::",
                stringify!(m_CapModes)
            )
        );
    }
    test_field_m_CapModes();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sLib3MFBall {
    pub m_Index: Lib3MF_uint32,
    pub m_Radius: Lib3MF_double,
}
#[test]
fn bindgen_test_layout_sLib3MFBall() {
    assert_eq!(
        ::std::mem::size_of::<sLib3MFBall>(),
        12usize,
        concat!("Size of: ", stringify!(sLib3MFBall))
    );
    assert_eq!(
        ::std::mem::align_of::<sLib3MFBall>(),
        1usize,
        concat!("Alignment of ", stringify!(sLib3MFBall))
    );
    fn test_field_m_Index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sLib3MFBall>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_Index) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sLib3MFBall),
                "::",
                stringify!(m_Index)
            )
        );
    }
    test_field_m_Index();
    fn test_field_m_Radius() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sLib3MFBall>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_Radius) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sLib3MFBall),
                "::",
                stringify!(m_Radius)
            )
        );
    }
    test_field_m_Radius();
}
#[doc = " Lib3MFProgressCallback - A callback function"]
#[doc = ""]
#[doc = " @param[out] pAbort - Returns whether the calculation should be aborted"]
#[doc = " @param[in] dProgressValue - The value of the progress function: values in the interval [0,1] are progress; < mean no progress update"]
#[doc = " @param[in] eProgressIdentifier - An identifier of progress"]
#[doc = " @param[in] pUserData - Userdata that is passed to the callback function"]
pub type Lib3MFProgressCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut bool,
        arg2: Lib3MF_double,
        arg3: eLib3MFProgressIdentifier,
        arg4: Lib3MF_pvoid,
    ),
>;
#[doc = " Lib3MFWriteCallback - Callback to call for writing a data chunk"]
#[doc = ""]
#[doc = " @param[in] nByteData - Pointer to the data to be written"]
#[doc = " @param[in] nNumBytes - Number of bytes to write"]
#[doc = " @param[in] pUserData - Userdata that is passed to the callback function"]
pub type Lib3MFWriteCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: Lib3MF_uint64, arg2: Lib3MF_uint64, arg3: Lib3MF_pvoid),
>;
#[doc = " Lib3MFReadCallback - Callback to call for reading a data chunk"]
#[doc = ""]
#[doc = " @param[in] nByteData - Pointer to a buffer to read data into"]
#[doc = " @param[in] nNumBytes - Number of bytes to read"]
#[doc = " @param[in] pUserData - Userdata that is passed to the callback function"]
pub type Lib3MFReadCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: Lib3MF_uint64, arg2: Lib3MF_uint64, arg3: Lib3MF_pvoid),
>;
#[doc = " Lib3MFSeekCallback - Callback to call for seeking in the stream"]
#[doc = ""]
#[doc = " @param[in] nPosition - Position in the stream to move to"]
#[doc = " @param[in] pUserData - Userdata that is passed to the callback function"]
pub type Lib3MFSeekCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: Lib3MF_uint64, arg2: Lib3MF_pvoid)>;
#[doc = " Lib3MFRandomNumberCallback - Callback to generate random numbers"]
#[doc = ""]
#[doc = " @param[in] nByteData - Pointer to a buffer to read data into"]
#[doc = " @param[in] nNumBytes - Size of available bytes in the buffer"]
#[doc = " @param[in] pUserData - Userdata that is passed to the callback function"]
#[doc = " @param[out] pBytesWritten - Number of bytes generated when succeed. 0 or less if failed."]
pub type Lib3MFRandomNumberCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: Lib3MF_uint64,
        arg2: Lib3MF_uint64,
        arg3: Lib3MF_pvoid,
        arg4: *mut Lib3MF_uint64,
    ),
>;
#[doc = " Lib3MFKeyWrappingCallback - A callback used to wrap (encrypt) the content key available in keystore resource group"]
#[doc = ""]
#[doc = " @param[in] pKEKParams - The information about the parameters used used to wrap the key to the contents"]
#[doc = " @param[in] nInBufferBufferSize - Number of elements in buffer"]
#[doc = " @param[in] pInBufferBuffer - uint8 buffer of Buffer to the input value. When encrypting, this should be the plain key. When decrypting, this should be the key cipher."]
#[doc = " @param[in] nOutBufferBufferSize - Number of elements in buffer"]
#[doc = " @param[out] pOutBufferNeededCount - will be filled with the count of the written elements, or needed buffer size."]
#[doc = " @param[out] pOutBufferBuffer - uint8  buffer of Buffer where the data will be placed. When encrypting, this will be the key cipher. When decrypting, this will be the plain key. When buffer is null, neededBytes contains the required bytes to run."]
#[doc = " @param[in] pUserData - Userdata that is passed to the callback function"]
#[doc = " @param[out] pStatus - The needed/encrypted/decrypted bytes when succeed or zero when error."]
pub type Lib3MFKeyWrappingCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: Lib3MF_AccessRight,
        arg2: Lib3MF_uint64,
        arg3: *const Lib3MF_uint8,
        arg4: Lib3MF_uint64,
        arg5: *mut Lib3MF_uint64,
        arg6: *mut Lib3MF_uint8,
        arg7: Lib3MF_pvoid,
        arg8: *mut Lib3MF_uint64,
    ),
>;
#[doc = " Lib3MFContentEncryptionCallback - A callback to encrypt/decrypt content called on each resource encrypted. This might be called several times depending on content size. If Input is not available(either null or size is 0), clients must return the result of authenticated tag generation/validation."]
#[doc = ""]
#[doc = " @param[in] pCEKParams - The params of the encryption process. Client must set/check AuthenticationTag when closing the encryption/decryption process."]
#[doc = " @param[in] nInputBufferSize - Number of elements in buffer"]
#[doc = " @param[in] pInputBuffer - uint8 buffer of Buffer to the original data. In encrypting, this will be the plain data. If decrypting, this will be the cipher data"]
#[doc = " @param[in] nOutputBufferSize - Number of elements in buffer"]
#[doc = " @param[out] pOutputNeededCount - will be filled with the count of the written elements, or needed buffer size."]
#[doc = " @param[out] pOutputBuffer - uint8  buffer of Buffer to hold the transformed data. When encrypting, this will be the cipher data. When decrypting, this shall be the plain data. If buffer is null, neededBytes return the necessary amount of bytes."]
#[doc = " @param[in] pUserData - Userdata that is passed to the callback function"]
#[doc = " @param[out] pStatus - The needed/encrypted/decrypted/verified bytes when succeed or zero when error."]
pub type Lib3MFContentEncryptionCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: Lib3MF_ContentEncryptionParams,
        arg2: Lib3MF_uint64,
        arg3: *const Lib3MF_uint8,
        arg4: Lib3MF_uint64,
        arg5: *mut Lib3MF_uint64,
        arg6: *mut Lib3MF_uint8,
        arg7: Lib3MF_pvoid,
        arg8: *mut Lib3MF_uint64,
    ),
>;
extern "C" {
    #[doc = " Writes out the model as file. The file type is specified by the Model Writer class."]
    #[doc = ""]
    #[doc = " @param[in] pWriter - Writer instance."]
    #[doc = " @param[in] pFilename - Filename to write into"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_writer_writetofile(
        pWriter: Lib3MF_Writer,
        pFilename: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves the size of the full 3MF file stream."]
    #[doc = ""]
    #[doc = " @param[in] pWriter - Writer instance."]
    #[doc = " @param[out] pStreamSize - the stream size"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_writer_getstreamsize(
        pWriter: Lib3MF_Writer,
        pStreamSize: *mut Lib3MF_uint64,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Writes out the 3MF file into a memory buffer"]
    #[doc = ""]
    #[doc = " @param[in] pWriter - Writer instance."]
    #[doc = " @param[in] nBufferBufferSize - Number of elements in buffer"]
    #[doc = " @param[out] pBufferNeededCount - will be filled with the count of the written elements, or needed buffer size."]
    #[doc = " @param[out] pBufferBuffer - uint8  buffer of buffer to write into"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_writer_writetobuffer(
        pWriter: Lib3MF_Writer,
        nBufferBufferSize: Lib3MF_uint64,
        pBufferNeededCount: *mut Lib3MF_uint64,
        pBufferBuffer: *mut Lib3MF_uint8,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Writes out the model and passes the data to a provided callback function. The file type is specified by the Model Writer class."]
    #[doc = ""]
    #[doc = " @param[in] pWriter - Writer instance."]
    #[doc = " @param[in] pTheWriteCallback - Callback to call for writing a data chunk"]
    #[doc = " @param[in] pTheSeekCallback - Callback to call for seeking in the stream"]
    #[doc = " @param[in] pUserData - Userdata that is passed to the callback function"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_writer_writetocallback(
        pWriter: Lib3MF_Writer,
        pTheWriteCallback: Lib3MFWriteCallback,
        pTheSeekCallback: Lib3MFSeekCallback,
        pUserData: Lib3MF_pvoid,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Set the progress callback for calls to this writer"]
    #[doc = ""]
    #[doc = " @param[in] pWriter - Writer instance."]
    #[doc = " @param[in] pProgressCallback - pointer to the callback function."]
    #[doc = " @param[in] pUserData - pointer to arbitrary user data that is passed without modification to the callback."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_writer_setprogresscallback(
        pWriter: Lib3MF_Writer,
        pProgressCallback: Lib3MFProgressCallback,
        pUserData: Lib3MF_pvoid,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the number of digits after the decimal point to be written in each vertex coordinate-value."]
    #[doc = ""]
    #[doc = " @param[in] pWriter - Writer instance."]
    #[doc = " @param[out] pDecimalPrecision - The number of digits to be written in each vertex coordinate-value after the decimal point."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_writer_getdecimalprecision(
        pWriter: Lib3MF_Writer,
        pDecimalPrecision: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the number of digits after the decimal point to be written in each vertex coordinate-value."]
    #[doc = ""]
    #[doc = " @param[in] pWriter - Writer instance."]
    #[doc = " @param[in] nDecimalPrecision - The number of digits to be written in each vertex coordinate-value after the decimal point."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_writer_setdecimalprecision(
        pWriter: Lib3MF_Writer,
        nDecimalPrecision: Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Activates (deactivates) the strict mode of the reader."]
    #[doc = ""]
    #[doc = " @param[in] pWriter - Writer instance."]
    #[doc = " @param[in] bStrictModeActive - flag whether strict mode is active or not."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_writer_setstrictmodeactive(
        pWriter: Lib3MF_Writer,
        bStrictModeActive: bool,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Queries whether the strict mode of the reader is active or not"]
    #[doc = ""]
    #[doc = " @param[in] pWriter - Writer instance."]
    #[doc = " @param[out] pStrictModeActive - returns flag whether strict mode is active or not."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_writer_getstrictmodeactive(
        pWriter: Lib3MF_Writer,
        pStrictModeActive: *mut bool,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns Warning and Error Information of the read process"]
    #[doc = ""]
    #[doc = " @param[in] pWriter - Writer instance."]
    #[doc = " @param[in] nIndex - Index of the Warning. Valid values are 0 to WarningCount - 1"]
    #[doc = " @param[out] pErrorCode - filled with the error code of the warning"]
    #[doc = " @param[in] nWarningBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pWarningNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pWarningBuffer -  buffer of the message of the warning, may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_writer_getwarning(
        pWriter: Lib3MF_Writer,
        nIndex: Lib3MF_uint32,
        pErrorCode: *mut Lib3MF_uint32,
        nWarningBufferSize: Lib3MF_uint32,
        pWarningNeededChars: *mut Lib3MF_uint32,
        pWarningBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns Warning and Error Count of the read process"]
    #[doc = ""]
    #[doc = " @param[in] pWriter - Writer instance."]
    #[doc = " @param[out] pCount - filled with the count of the occurred warnings."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_writer_getwarningcount(
        pWriter: Lib3MF_Writer,
        pCount: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Registers a callback to deal with data key encryption/decryption from keystore"]
    #[doc = ""]
    #[doc = " @param[in] pWriter - Writer instance."]
    #[doc = " @param[in] pConsumerID - The ConsumerID to register for"]
    #[doc = " @param[in] pTheCallback - The callback to be callede for wrapping and encryption key"]
    #[doc = " @param[in] pUserData - Userdata that is passed to the callback function"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_writer_addkeywrappingcallback(
        pWriter: Lib3MF_Writer,
        pConsumerID: *const ::std::os::raw::c_char,
        pTheCallback: Lib3MFKeyWrappingCallback,
        pUserData: Lib3MF_pvoid,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Registers a callback to deal with encryption of content"]
    #[doc = ""]
    #[doc = " @param[in] pWriter - Writer instance."]
    #[doc = " @param[in] pTheCallback - The callback used to encrypt content"]
    #[doc = " @param[in] pUserData - Userdata that is passed to the callback function"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_writer_setcontentencryptioncallback(
        pWriter: Lib3MF_Writer,
        pTheCallback: Lib3MFContentEncryptionCallback,
        pUserData: Lib3MF_pvoid,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Reads a model from a file. The file type is specified by the Model Reader class"]
    #[doc = ""]
    #[doc = " @param[in] pReader - Reader instance."]
    #[doc = " @param[in] pFilename - Filename to read from"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_reader_readfromfile(
        pReader: Lib3MF_Reader,
        pFilename: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Reads a model from a memory buffer."]
    #[doc = ""]
    #[doc = " @param[in] pReader - Reader instance."]
    #[doc = " @param[in] nBufferBufferSize - Number of elements in buffer"]
    #[doc = " @param[in] pBufferBuffer - uint8 buffer of Buffer to read from"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_reader_readfrombuffer(
        pReader: Lib3MF_Reader,
        nBufferBufferSize: Lib3MF_uint64,
        pBufferBuffer: *const Lib3MF_uint8,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Reads a model and from the data provided by a callback function"]
    #[doc = ""]
    #[doc = " @param[in] pReader - Reader instance."]
    #[doc = " @param[in] pTheReadCallback - Callback to call for reading a data chunk"]
    #[doc = " @param[in] nStreamSize - number of bytes the callback returns"]
    #[doc = " @param[in] pTheSeekCallback - Callback to call for seeking in the stream."]
    #[doc = " @param[in] pUserData - Userdata that is passed to the callback function"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_reader_readfromcallback(
        pReader: Lib3MF_Reader,
        pTheReadCallback: Lib3MFReadCallback,
        nStreamSize: Lib3MF_uint64,
        pTheSeekCallback: Lib3MFSeekCallback,
        pUserData: Lib3MF_pvoid,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Set the progress callback for calls to this writer"]
    #[doc = ""]
    #[doc = " @param[in] pReader - Reader instance."]
    #[doc = " @param[in] pProgressCallback - pointer to the callback function."]
    #[doc = " @param[in] pUserData - pointer to arbitrary user data that is passed without modification to the callback."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_reader_setprogresscallback(
        pReader: Lib3MF_Reader,
        pProgressCallback: Lib3MFProgressCallback,
        pUserData: Lib3MF_pvoid,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Adds a relationship type which shall be read as attachment in memory while loading"]
    #[doc = ""]
    #[doc = " @param[in] pReader - Reader instance."]
    #[doc = " @param[in] pRelationShipType - String of the relationship type"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_reader_addrelationtoread(
        pReader: Lib3MF_Reader,
        pRelationShipType: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Removes a relationship type which shall be read as attachment in memory while loading"]
    #[doc = ""]
    #[doc = " @param[in] pReader - Reader instance."]
    #[doc = " @param[in] pRelationShipType - String of the relationship type"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_reader_removerelationtoread(
        pReader: Lib3MF_Reader,
        pRelationShipType: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Activates (deactivates) the strict mode of the reader."]
    #[doc = ""]
    #[doc = " @param[in] pReader - Reader instance."]
    #[doc = " @param[in] bStrictModeActive - flag whether strict mode is active or not."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_reader_setstrictmodeactive(
        pReader: Lib3MF_Reader,
        bStrictModeActive: bool,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Queries whether the strict mode of the reader is active or not"]
    #[doc = ""]
    #[doc = " @param[in] pReader - Reader instance."]
    #[doc = " @param[out] pStrictModeActive - returns flag whether strict mode is active or not."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_reader_getstrictmodeactive(
        pReader: Lib3MF_Reader,
        pStrictModeActive: *mut bool,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns Warning and Error Information of the read process"]
    #[doc = ""]
    #[doc = " @param[in] pReader - Reader instance."]
    #[doc = " @param[in] nIndex - Index of the Warning. Valid values are 0 to WarningCount - 1"]
    #[doc = " @param[out] pErrorCode - filled with the error code of the warning"]
    #[doc = " @param[in] nWarningBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pWarningNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pWarningBuffer -  buffer of the message of the warning, may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_reader_getwarning(
        pReader: Lib3MF_Reader,
        nIndex: Lib3MF_uint32,
        pErrorCode: *mut Lib3MF_uint32,
        nWarningBufferSize: Lib3MF_uint32,
        pWarningNeededChars: *mut Lib3MF_uint32,
        pWarningBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns Warning and Error Count of the read process"]
    #[doc = ""]
    #[doc = " @param[in] pReader - Reader instance."]
    #[doc = " @param[out] pCount - filled with the count of the occurred warnings."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_reader_getwarningcount(
        pReader: Lib3MF_Reader,
        pCount: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Registers a callback to deal with key wrapping mechanism from keystore"]
    #[doc = ""]
    #[doc = " @param[in] pReader - Reader instance."]
    #[doc = " @param[in] pConsumerID - The ConsumerID to register for"]
    #[doc = " @param[in] pTheCallback - The callback used to decrypt data key"]
    #[doc = " @param[in] pUserData - Userdata that is passed to the callback function"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_reader_addkeywrappingcallback(
        pReader: Lib3MF_Reader,
        pConsumerID: *const ::std::os::raw::c_char,
        pTheCallback: Lib3MFKeyWrappingCallback,
        pUserData: Lib3MF_pvoid,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Registers a callback to deal with encryption of content"]
    #[doc = ""]
    #[doc = " @param[in] pReader - Reader instance."]
    #[doc = " @param[in] pTheCallback - The callback used to encrypt content"]
    #[doc = " @param[in] pUserData - Userdata that is passed to the callback function"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_reader_setcontentencryptioncallback(
        pReader: Lib3MF_Reader,
        pTheCallback: Lib3MFContentEncryptionCallback,
        pUserData: Lib3MF_pvoid,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the absolute path of this PackagePart."]
    #[doc = ""]
    #[doc = " @param[in] pPackagePart - PackagePart instance."]
    #[doc = " @param[in] nPathBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pPathNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pPathBuffer -  buffer of Returns the absolute path of this PackagePart, may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_packagepart_getpath(
        pPackagePart: Lib3MF_PackagePart,
        nPathBufferSize: Lib3MF_uint32,
        pPathNeededChars: *mut Lib3MF_uint32,
        pPathBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the absolute path of this PackagePart."]
    #[doc = ""]
    #[doc = " @param[in] pPackagePart - PackagePart instance."]
    #[doc = " @param[in] pPath - Sets the absolute path of this PackagePart."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_packagepart_setpath(
        pPackagePart: Lib3MF_PackagePart,
        pPath: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves the unique id of this resource within a package. This function will be removed in a later release in favor of GetUniqueResourceID"]
    #[doc = ""]
    #[doc = " @param[in] pResource - Resource instance."]
    #[doc = " @param[out] pUniqueResourceID - Retrieves the unique id of this resource within a package."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_resource_getresourceid(
        pResource: Lib3MF_Resource,
        pUniqueResourceID: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves the unique id of this resource within a package."]
    #[doc = ""]
    #[doc = " @param[in] pResource - Resource instance."]
    #[doc = " @param[out] pUniqueResourceID - Retrieves the unique id of this resource within a package."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_resource_getuniqueresourceid(
        pResource: Lib3MF_Resource,
        pUniqueResourceID: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the PackagePart within which this resource resides"]
    #[doc = ""]
    #[doc = " @param[in] pResource - Resource instance."]
    #[doc = " @param[out] pPackagePart - the PackagePart within which this resource resides."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_resource_packagepart(
        pResource: Lib3MF_Resource,
        pPackagePart: *mut Lib3MF_PackagePart,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the new PackagePart within which this resource resides"]
    #[doc = ""]
    #[doc = " @param[in] pResource - Resource instance."]
    #[doc = " @param[in] pPackagePart - the new PackagePart within which this resource resides."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_resource_setpackagepart(
        pResource: Lib3MF_Resource,
        pPackagePart: Lib3MF_PackagePart,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves the id of this resource within a model."]
    #[doc = ""]
    #[doc = " @param[in] pResource - Resource instance."]
    #[doc = " @param[out] pModelResourceId - Retrieves the id of this resource within a model."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_resource_getmodelresourceid(
        pResource: Lib3MF_Resource,
        pModelResourceId: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Iterates to the next resource in the list."]
    #[doc = ""]
    #[doc = " @param[in] pResourceIterator - ResourceIterator instance."]
    #[doc = " @param[out] pHasNext - Iterates to the next resource in the list."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_resourceiterator_movenext(
        pResourceIterator: Lib3MF_ResourceIterator,
        pHasNext: *mut bool,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Iterates to the previous resource in the list."]
    #[doc = ""]
    #[doc = " @param[in] pResourceIterator - ResourceIterator instance."]
    #[doc = " @param[out] pHasPrevious - Iterates to the previous resource in the list."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_resourceiterator_moveprevious(
        pResourceIterator: Lib3MF_ResourceIterator,
        pHasPrevious: *mut bool,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the resource the iterator points at."]
    #[doc = ""]
    #[doc = " @param[in] pResourceIterator - ResourceIterator instance."]
    #[doc = " @param[out] pResource - returns the resource instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_resourceiterator_getcurrent(
        pResourceIterator: Lib3MF_ResourceIterator,
        pResource: *mut Lib3MF_Resource,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Creates a new resource iterator with the same resource list."]
    #[doc = ""]
    #[doc = " @param[in] pResourceIterator - ResourceIterator instance."]
    #[doc = " @param[out] pOutResourceIterator - returns the cloned Iterator instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_resourceiterator_clone(
        pResourceIterator: Lib3MF_ResourceIterator,
        pOutResourceIterator: *mut Lib3MF_ResourceIterator,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the number of resoucres the iterator captures."]
    #[doc = ""]
    #[doc = " @param[in] pResourceIterator - ResourceIterator instance."]
    #[doc = " @param[out] pCount - returns the number of resoucres the iterator captures."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_resourceiterator_count(
        pResourceIterator: Lib3MF_ResourceIterator,
        pCount: *mut Lib3MF_uint64,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the SliceStack the iterator points at."]
    #[doc = ""]
    #[doc = " @param[in] pSliceStackIterator - SliceStackIterator instance."]
    #[doc = " @param[out] pResource - returns the SliceStack instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_slicestackiterator_getcurrentslicestack(
        pSliceStackIterator: Lib3MF_SliceStackIterator,
        pResource: *mut Lib3MF_SliceStack,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the Object the iterator points at."]
    #[doc = ""]
    #[doc = " @param[in] pObjectIterator - ObjectIterator instance."]
    #[doc = " @param[out] pResource - returns the Object instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_objectiterator_getcurrentobject(
        pObjectIterator: Lib3MF_ObjectIterator,
        pResource: *mut Lib3MF_Object,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the MeshObject the iterator points at."]
    #[doc = ""]
    #[doc = " @param[in] pMeshObjectIterator - MeshObjectIterator instance."]
    #[doc = " @param[out] pResource - returns the MeshObject instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_meshobjectiterator_getcurrentmeshobject(
        pMeshObjectIterator: Lib3MF_MeshObjectIterator,
        pResource: *mut Lib3MF_MeshObject,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the ComponentsObject the iterator points at."]
    #[doc = ""]
    #[doc = " @param[in] pComponentsObjectIterator - ComponentsObjectIterator instance."]
    #[doc = " @param[out] pResource - returns the ComponentsObject instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_componentsobjectiterator_getcurrentcomponentsobject(
        pComponentsObjectIterator: Lib3MF_ComponentsObjectIterator,
        pResource: *mut Lib3MF_ComponentsObject,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the Texture2D the iterator points at."]
    #[doc = ""]
    #[doc = " @param[in] pTexture2DIterator - Texture2DIterator instance."]
    #[doc = " @param[out] pResource - returns the Texture2D instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_texture2diterator_getcurrenttexture2d(
        pTexture2DIterator: Lib3MF_Texture2DIterator,
        pResource: *mut Lib3MF_Texture2D,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the MaterialGroup the iterator points at."]
    #[doc = ""]
    #[doc = " @param[in] pBaseMaterialGroupIterator - BaseMaterialGroupIterator instance."]
    #[doc = " @param[out] pResource - returns the BaseMaterialGroup instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_basematerialgroupiterator_getcurrentbasematerialgroup(
        pBaseMaterialGroupIterator: Lib3MF_BaseMaterialGroupIterator,
        pResource: *mut Lib3MF_BaseMaterialGroup,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the ColorGroup the iterator points at."]
    #[doc = ""]
    #[doc = " @param[in] pColorGroupIterator - ColorGroupIterator instance."]
    #[doc = " @param[out] pResource - returns the ColorGroup instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_colorgroupiterator_getcurrentcolorgroup(
        pColorGroupIterator: Lib3MF_ColorGroupIterator,
        pResource: *mut Lib3MF_ColorGroup,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the Texture2DGroup the iterator points at."]
    #[doc = ""]
    #[doc = " @param[in] pTexture2DGroupIterator - Texture2DGroupIterator instance."]
    #[doc = " @param[out] pResource - returns the Texture2DGroup instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_texture2dgroupiterator_getcurrenttexture2dgroup(
        pTexture2DGroupIterator: Lib3MF_Texture2DGroupIterator,
        pResource: *mut Lib3MF_Texture2DGroup,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the CompositeMaterials the iterator points at."]
    #[doc = ""]
    #[doc = " @param[in] pCompositeMaterialsIterator - CompositeMaterialsIterator instance."]
    #[doc = " @param[out] pResource - returns the CompositeMaterials instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_compositematerialsiterator_getcurrentcompositematerials(
        pCompositeMaterialsIterator: Lib3MF_CompositeMaterialsIterator,
        pResource: *mut Lib3MF_CompositeMaterials,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the MultiPropertyGroup the iterator points at."]
    #[doc = ""]
    #[doc = " @param[in] pMultiPropertyGroupIterator - MultiPropertyGroupIterator instance."]
    #[doc = " @param[out] pResource - returns the MultiPropertyGroup instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_multipropertygroupiterator_getcurrentmultipropertygroup(
        pMultiPropertyGroupIterator: Lib3MF_MultiPropertyGroupIterator,
        pResource: *mut Lib3MF_MultiPropertyGroup,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " returns the namespace URL of the metadata"]
    #[doc = ""]
    #[doc = " @param[in] pMetaData - MetaData instance."]
    #[doc = " @param[in] nNameSpaceBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pNameSpaceNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pNameSpaceBuffer -  buffer of the namespace URL of the metadata, may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_metadata_getnamespace(
        pMetaData: Lib3MF_MetaData,
        nNameSpaceBufferSize: Lib3MF_uint32,
        pNameSpaceNeededChars: *mut Lib3MF_uint32,
        pNameSpaceBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " sets a new namespace URL of the metadata"]
    #[doc = ""]
    #[doc = " @param[in] pMetaData - MetaData instance."]
    #[doc = " @param[in] pNameSpace - the new namespace URL of the metadata"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_metadata_setnamespace(
        pMetaData: Lib3MF_MetaData,
        pNameSpace: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " returns the name of a metadata"]
    #[doc = ""]
    #[doc = " @param[in] pMetaData - MetaData instance."]
    #[doc = " @param[in] nNameBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pNameNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pNameBuffer -  buffer of the name of the metadata, may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_metadata_getname(
        pMetaData: Lib3MF_MetaData,
        nNameBufferSize: Lib3MF_uint32,
        pNameNeededChars: *mut Lib3MF_uint32,
        pNameBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " sets a new name of a metadata"]
    #[doc = ""]
    #[doc = " @param[in] pMetaData - MetaData instance."]
    #[doc = " @param[in] pName - the new name of the metadata"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_metadata_setname(
        pMetaData: Lib3MF_MetaData,
        pName: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " returns the (namespace+name) of a metadata"]
    #[doc = ""]
    #[doc = " @param[in] pMetaData - MetaData instance."]
    #[doc = " @param[in] nKeyBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pKeyNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pKeyBuffer -  buffer of the key (namespace+name) of the metadata, may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_metadata_getkey(
        pMetaData: Lib3MF_MetaData,
        nKeyBufferSize: Lib3MF_uint32,
        pKeyNeededChars: *mut Lib3MF_uint32,
        pKeyBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " returns, whether a metadata must be preserved"]
    #[doc = ""]
    #[doc = " @param[in] pMetaData - MetaData instance."]
    #[doc = " @param[out] pMustPreserve - returns, whether a metadata must be preserved"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_metadata_getmustpreserve(
        pMetaData: Lib3MF_MetaData,
        pMustPreserve: *mut bool,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " sets whether a metadata must be preserved"]
    #[doc = ""]
    #[doc = " @param[in] pMetaData - MetaData instance."]
    #[doc = " @param[in] bMustPreserve - a new value whether a metadata must be preserved"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_metadata_setmustpreserve(
        pMetaData: Lib3MF_MetaData,
        bMustPreserve: bool,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " returns the type of a metadata"]
    #[doc = ""]
    #[doc = " @param[in] pMetaData - MetaData instance."]
    #[doc = " @param[in] nTypeBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pTypeNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pTypeBuffer -  buffer of the type of the metadata, may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_metadata_gettype(
        pMetaData: Lib3MF_MetaData,
        nTypeBufferSize: Lib3MF_uint32,
        pTypeNeededChars: *mut Lib3MF_uint32,
        pTypeBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " sets a new type of a metadata. This must be a simple XML type"]
    #[doc = ""]
    #[doc = " @param[in] pMetaData - MetaData instance."]
    #[doc = " @param[in] pType - a new type of the metadata"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_metadata_settype(
        pMetaData: Lib3MF_MetaData,
        pType: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " returns the value of the metadata"]
    #[doc = ""]
    #[doc = " @param[in] pMetaData - MetaData instance."]
    #[doc = " @param[in] nValueBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pValueNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pValueBuffer -  buffer of the value of the metadata, may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_metadata_getvalue(
        pMetaData: Lib3MF_MetaData,
        nValueBufferSize: Lib3MF_uint32,
        pValueNeededChars: *mut Lib3MF_uint32,
        pValueBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " sets a new value of the metadata"]
    #[doc = ""]
    #[doc = " @param[in] pMetaData - MetaData instance."]
    #[doc = " @param[in] pValue - a new value of the metadata"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_metadata_setvalue(
        pMetaData: Lib3MF_MetaData,
        pValue: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " returns the number of metadata in this metadatagroup"]
    #[doc = ""]
    #[doc = " @param[in] pMetaDataGroup - MetaDataGroup instance."]
    #[doc = " @param[out] pCount - returns the number metadata"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_metadatagroup_getmetadatacount(
        pMetaDataGroup: Lib3MF_MetaDataGroup,
        pCount: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " returns a metadata value within this metadatagroup"]
    #[doc = ""]
    #[doc = " @param[in] pMetaDataGroup - MetaDataGroup instance."]
    #[doc = " @param[in] nIndex - Index of the Metadata."]
    #[doc = " @param[out] pMetaData - an instance of the metadata"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_metadatagroup_getmetadata(
        pMetaDataGroup: Lib3MF_MetaDataGroup,
        nIndex: Lib3MF_uint32,
        pMetaData: *mut Lib3MF_MetaData,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " returns a metadata value within this metadatagroup"]
    #[doc = ""]
    #[doc = " @param[in] pMetaDataGroup - MetaDataGroup instance."]
    #[doc = " @param[in] pNameSpace - the namespace of the metadata"]
    #[doc = " @param[in] pName - the name of the Metadata"]
    #[doc = " @param[out] pMetaData - an instance of the metadata"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_metadatagroup_getmetadatabykey(
        pMetaDataGroup: Lib3MF_MetaDataGroup,
        pNameSpace: *const ::std::os::raw::c_char,
        pName: *const ::std::os::raw::c_char,
        pMetaData: *mut Lib3MF_MetaData,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " removes metadata by index from the model."]
    #[doc = ""]
    #[doc = " @param[in] pMetaDataGroup - MetaDataGroup instance."]
    #[doc = " @param[in] nIndex -  Index of the metadata to remove"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_metadatagroup_removemetadatabyindex(
        pMetaDataGroup: Lib3MF_MetaDataGroup,
        nIndex: Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " removes metadata from the model."]
    #[doc = ""]
    #[doc = " @param[in] pMetaDataGroup - MetaDataGroup instance."]
    #[doc = " @param[in] pTheMetaData - The metadata to remove"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_metadatagroup_removemetadata(
        pMetaDataGroup: Lib3MF_MetaDataGroup,
        pTheMetaData: Lib3MF_MetaData,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " adds a new metadata to this metadatagroup"]
    #[doc = ""]
    #[doc = " @param[in] pMetaDataGroup - MetaDataGroup instance."]
    #[doc = " @param[in] pNameSpace - the namespace of the metadata"]
    #[doc = " @param[in] pName - the name of the metadata"]
    #[doc = " @param[in] pValue - the value of the metadata"]
    #[doc = " @param[in] pType - the type of the metadata"]
    #[doc = " @param[in] bMustPreserve - shuold the metadata be preserved"]
    #[doc = " @param[out] pMetaData - a new instance of the metadata"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_metadatagroup_addmetadata(
        pMetaDataGroup: Lib3MF_MetaDataGroup,
        pNameSpace: *const ::std::os::raw::c_char,
        pName: *const ::std::os::raw::c_char,
        pValue: *const ::std::os::raw::c_char,
        pType: *const ::std::os::raw::c_char,
        bMustPreserve: bool,
        pMetaData: *mut Lib3MF_MetaData,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves an object's type"]
    #[doc = ""]
    #[doc = " @param[in] pObject - Object instance."]
    #[doc = " @param[out] pObjectType - returns object type enum."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_object_gettype(
        pObject: Lib3MF_Object,
        pObjectType: *mut eLib3MFObjectType,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets an object's type"]
    #[doc = ""]
    #[doc = " @param[in] pObject - Object instance."]
    #[doc = " @param[in] eObjectType - object type enum."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_object_settype(
        pObject: Lib3MF_Object,
        eObjectType: eLib3MFObjectType,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves an object's name"]
    #[doc = ""]
    #[doc = " @param[in] pObject - Object instance."]
    #[doc = " @param[in] nNameBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pNameNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pNameBuffer -  buffer of returns object name., may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_object_getname(
        pObject: Lib3MF_Object,
        nNameBufferSize: Lib3MF_uint32,
        pNameNeededChars: *mut Lib3MF_uint32,
        pNameBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets an object's name string"]
    #[doc = ""]
    #[doc = " @param[in] pObject - Object instance."]
    #[doc = " @param[in] pName - new object name."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_object_setname(
        pObject: Lib3MF_Object,
        pName: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves an object's part number"]
    #[doc = ""]
    #[doc = " @param[in] pObject - Object instance."]
    #[doc = " @param[in] nPartNumberBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pPartNumberNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pPartNumberBuffer -  buffer of returns object part number., may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_object_getpartnumber(
        pObject: Lib3MF_Object,
        nPartNumberBufferSize: Lib3MF_uint32,
        pPartNumberNeededChars: *mut Lib3MF_uint32,
        pPartNumberBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets an objects partnumber string"]
    #[doc = ""]
    #[doc = " @param[in] pObject - Object instance."]
    #[doc = " @param[in] pPartNumber - new object part number."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_object_setpartnumber(
        pObject: Lib3MF_Object,
        pPartNumber: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves, if an object is a mesh object"]
    #[doc = ""]
    #[doc = " @param[in] pObject - Object instance."]
    #[doc = " @param[out] pIsMeshObject - returns, whether the object is a mesh object"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_object_ismeshobject(
        pObject: Lib3MF_Object,
        pIsMeshObject: *mut bool,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves, if an object is a components object"]
    #[doc = ""]
    #[doc = " @param[in] pObject - Object instance."]
    #[doc = " @param[out] pIsComponentsObject - returns, whether the object is a components object"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_object_iscomponentsobject(
        pObject: Lib3MF_Object,
        pIsComponentsObject: *mut bool,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves, if the object is valid according to the core spec. For mesh objects, we distinguish between the type attribute of the object:In case of object type other, this always means false.In case of object type model or solidsupport, this means, if the mesh suffices all requirements of the core spec chapter 4.1.In case of object type support or surface, this always means true.A component objects is valid if and only if it contains at least one component and all child components are valid objects."]
    #[doc = ""]
    #[doc = " @param[in] pObject - Object instance."]
    #[doc = " @param[out] pIsValid - returns whether the object is a valid object description"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_object_isvalid(pObject: Lib3MF_Object, pIsValid: *mut bool) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Use an existing attachment as thumbnail for this object"]
    #[doc = ""]
    #[doc = " @param[in] pObject - Object instance."]
    #[doc = " @param[in] pAttachment - Instance of a new or the existing thumbnailattachment object."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_object_setattachmentasthumbnail(
        pObject: Lib3MF_Object,
        pAttachment: Lib3MF_Attachment,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Get the attachment containing the object thumbnail."]
    #[doc = ""]
    #[doc = " @param[in] pObject - Object instance."]
    #[doc = " @param[out] pAttachment - Instance of the thumbnailattachment object or NULL."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_object_getthumbnailattachment(
        pObject: Lib3MF_Object,
        pAttachment: *mut Lib3MF_Attachment,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Clears the attachment. The attachment instance is not removed from the package."]
    #[doc = ""]
    #[doc = " @param[in] pObject - Object instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_object_clearthumbnailattachment(pObject: Lib3MF_Object) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the outbox of a build item"]
    #[doc = ""]
    #[doc = " @param[in] pObject - Object instance."]
    #[doc = " @param[out] pOutbox - Outbox of this build item"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_object_getoutbox(
        pObject: Lib3MF_Object,
        pOutbox: *mut sLib3MFBox,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves an object's uuid string (see production extension specification)"]
    #[doc = ""]
    #[doc = " @param[in] pObject - Object instance."]
    #[doc = " @param[out] pHasUUID - flag whether the build item has a UUID"]
    #[doc = " @param[in] nUUIDBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pUUIDNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pUUIDBuffer -  buffer of returns object uuid., may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_object_getuuid(
        pObject: Lib3MF_Object,
        pHasUUID: *mut bool,
        nUUIDBufferSize: Lib3MF_uint32,
        pUUIDNeededChars: *mut Lib3MF_uint32,
        pUUIDBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets a build object's uuid string (see production extension specification)"]
    #[doc = ""]
    #[doc = " @param[in] pObject - Object instance."]
    #[doc = " @param[in] pUUID - new object uuid string."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_object_setuuid(
        pObject: Lib3MF_Object,
        pUUID: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the metadatagroup of this object"]
    #[doc = ""]
    #[doc = " @param[in] pObject - Object instance."]
    #[doc = " @param[out] pMetaDataGroup - returns an Instance of the metadatagroup of this object"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_object_getmetadatagroup(
        pObject: Lib3MF_Object,
        pMetaDataGroup: *mut Lib3MF_MetaDataGroup,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " set the meshresolution of the mesh object"]
    #[doc = ""]
    #[doc = " @param[in] pObject - Object instance."]
    #[doc = " @param[in] eMeshResolution - meshresolution of this object"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_object_setslicesmeshresolution(
        pObject: Lib3MF_Object,
        eMeshResolution: eLib3MFSlicesMeshResolution,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " get the meshresolution of the mesh object"]
    #[doc = ""]
    #[doc = " @param[in] pObject - Object instance."]
    #[doc = " @param[out] pMeshResolution - meshresolution of this object"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_object_getslicesmeshresolution(
        pObject: Lib3MF_Object,
        pMeshResolution: *mut eLib3MFSlicesMeshResolution,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " returns whether the Object has a slice stack. If Recursive is true, also checks whether any references object has a slice stack"]
    #[doc = ""]
    #[doc = " @param[in] pObject - Object instance."]
    #[doc = " @param[in] bRecursive - check also all referenced objects?"]
    #[doc = " @param[out] pHasSlices - does the object have a slice stack?"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_object_hasslices(
        pObject: Lib3MF_Object,
        bRecursive: bool,
        pHasSlices: *mut bool,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " unlinks the attached slicestack from this object. If no slice stack is attached, do noting."]
    #[doc = ""]
    #[doc = " @param[in] pObject - Object instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_object_clearslicestack(pObject: Lib3MF_Object) -> Lib3MFResult;
}
extern "C" {
    #[doc = " get the Slicestack attached to the object"]
    #[doc = ""]
    #[doc = " @param[in] pObject - Object instance."]
    #[doc = " @param[out] pSliceStackInstance - returns the slicestack instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_object_getslicestack(
        pObject: Lib3MF_Object,
        pSliceStackInstance: *mut Lib3MF_SliceStack,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " assigns a slicestack to the object"]
    #[doc = ""]
    #[doc = " @param[in] pObject - Object instance."]
    #[doc = " @param[in] pSliceStackInstance - the new slice stack of this Object"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_object_assignslicestack(
        pObject: Lib3MF_Object,
        pSliceStackInstance: Lib3MF_SliceStack,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the vertex count of a mesh object."]
    #[doc = ""]
    #[doc = " @param[in] pMeshObject - MeshObject instance."]
    #[doc = " @param[out] pVertexCount - filled with the vertex count."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_meshobject_getvertexcount(
        pMeshObject: Lib3MF_MeshObject,
        pVertexCount: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the triangle count of a mesh object."]
    #[doc = ""]
    #[doc = " @param[in] pMeshObject - MeshObject instance."]
    #[doc = " @param[out] pVertexCount - filled with the triangle count."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_meshobject_gettrianglecount(
        pMeshObject: Lib3MF_MeshObject,
        pVertexCount: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the vertex count of a mesh object."]
    #[doc = ""]
    #[doc = " @param[in] pMeshObject - MeshObject instance."]
    #[doc = " @param[in] nIndex - Index of the vertex (0 to vertexcount - 1)"]
    #[doc = " @param[out] pCoordinates - filled with the vertex coordinates."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_meshobject_getvertex(
        pMeshObject: Lib3MF_MeshObject,
        nIndex: Lib3MF_uint32,
        pCoordinates: *mut sLib3MFPosition,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the coordinates of a single vertex of a mesh object"]
    #[doc = ""]
    #[doc = " @param[in] pMeshObject - MeshObject instance."]
    #[doc = " @param[in] nIndex - Index of the vertex (0 to vertexcount - 1)"]
    #[doc = " @param[in] pCoordinates - contains the vertex coordinates."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_meshobject_setvertex(
        pMeshObject: Lib3MF_MeshObject,
        nIndex: Lib3MF_uint32,
        pCoordinates: *const sLib3MFPosition,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Adds a single vertex to a mesh object"]
    #[doc = ""]
    #[doc = " @param[in] pMeshObject - MeshObject instance."]
    #[doc = " @param[in] pCoordinates - contains the vertex coordinates."]
    #[doc = " @param[out] pNewIndex - Index of the new vertex"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_meshobject_addvertex(
        pMeshObject: Lib3MF_MeshObject,
        pCoordinates: *const sLib3MFPosition,
        pNewIndex: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Obtains all vertex positions of a mesh object"]
    #[doc = ""]
    #[doc = " @param[in] pMeshObject - MeshObject instance."]
    #[doc = " @param[in] nVerticesBufferSize - Number of elements in buffer"]
    #[doc = " @param[out] pVerticesNeededCount - will be filled with the count of the written elements, or needed buffer size."]
    #[doc = " @param[out] pVerticesBuffer - Position  buffer of contains the vertex coordinates."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_meshobject_getvertices(
        pMeshObject: Lib3MF_MeshObject,
        nVerticesBufferSize: Lib3MF_uint64,
        pVerticesNeededCount: *mut Lib3MF_uint64,
        pVerticesBuffer: *mut sLib3MFPosition,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns indices of a single triangle of a mesh object."]
    #[doc = ""]
    #[doc = " @param[in] pMeshObject - MeshObject instance."]
    #[doc = " @param[in] nIndex - Index of the triangle (0 to trianglecount - 1)"]
    #[doc = " @param[out] pIndices - filled with the triangle indices."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_meshobject_gettriangle(
        pMeshObject: Lib3MF_MeshObject,
        nIndex: Lib3MF_uint32,
        pIndices: *mut sLib3MFTriangle,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the indices of a single triangle of a mesh object."]
    #[doc = ""]
    #[doc = " @param[in] pMeshObject - MeshObject instance."]
    #[doc = " @param[in] nIndex - Index of the triangle (0 to trianglecount - 1)"]
    #[doc = " @param[in] pIndices - contains the triangle indices."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_meshobject_settriangle(
        pMeshObject: Lib3MF_MeshObject,
        nIndex: Lib3MF_uint32,
        pIndices: *const sLib3MFTriangle,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Adds a single triangle to a mesh object"]
    #[doc = ""]
    #[doc = " @param[in] pMeshObject - MeshObject instance."]
    #[doc = " @param[in] pIndices - contains the triangle indices."]
    #[doc = " @param[out] pNewIndex - Index of the new triangle"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_meshobject_addtriangle(
        pMeshObject: Lib3MF_MeshObject,
        pIndices: *const sLib3MFTriangle,
        pNewIndex: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Get all triangles of a mesh object"]
    #[doc = ""]
    #[doc = " @param[in] pMeshObject - MeshObject instance."]
    #[doc = " @param[in] nIndicesBufferSize - Number of elements in buffer"]
    #[doc = " @param[out] pIndicesNeededCount - will be filled with the count of the written elements, or needed buffer size."]
    #[doc = " @param[out] pIndicesBuffer - Triangle  buffer of contains the triangle indices."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_meshobject_gettriangleindices(
        pMeshObject: Lib3MF_MeshObject,
        nIndicesBufferSize: Lib3MF_uint64,
        pIndicesNeededCount: *mut Lib3MF_uint64,
        pIndicesBuffer: *mut sLib3MFTriangle,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the property at the object-level of the mesh object."]
    #[doc = ""]
    #[doc = " @param[in] pMeshObject - MeshObject instance."]
    #[doc = " @param[in] nUniqueResourceID - the object-level Property UniqueResourceID."]
    #[doc = " @param[in] nPropertyID - the object-level PropertyID."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_meshobject_setobjectlevelproperty(
        pMeshObject: Lib3MF_MeshObject,
        nUniqueResourceID: Lib3MF_uint32,
        nPropertyID: Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Gets the property at the object-level of the mesh object."]
    #[doc = ""]
    #[doc = " @param[in] pMeshObject - MeshObject instance."]
    #[doc = " @param[out] pUniqueResourceID - the object-level Property UniqueResourceID."]
    #[doc = " @param[out] pPropertyID - the object-level PropertyID."]
    #[doc = " @param[out] pHasObjectLevelProperty - Has an object-level property been specified?"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_meshobject_getobjectlevelproperty(
        pMeshObject: Lib3MF_MeshObject,
        pUniqueResourceID: *mut Lib3MF_uint32,
        pPropertyID: *mut Lib3MF_uint32,
        pHasObjectLevelProperty: *mut bool,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the properties of a single triangle of a mesh object."]
    #[doc = ""]
    #[doc = " @param[in] pMeshObject - MeshObject instance."]
    #[doc = " @param[in] nIndex - Index of the triangle (0 to trianglecount - 1)"]
    #[doc = " @param[in] pProperties - contains the triangle properties."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_meshobject_settriangleproperties(
        pMeshObject: Lib3MF_MeshObject,
        nIndex: Lib3MF_uint32,
        pProperties: *const sLib3MFTriangleProperties,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Gets the properties of a single triangle of a mesh object."]
    #[doc = ""]
    #[doc = " @param[in] pMeshObject - MeshObject instance."]
    #[doc = " @param[in] nIndex - Index of the triangle (0 to trianglecount - 1)"]
    #[doc = " @param[out] pProperty - returns the triangle properties."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_meshobject_gettriangleproperties(
        pMeshObject: Lib3MF_MeshObject,
        nIndex: Lib3MF_uint32,
        pProperty: *mut sLib3MFTriangleProperties,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the properties of all triangles of a mesh object. Sets the object level property to the first entry of the passed triangle properties, if not yet specified."]
    #[doc = ""]
    #[doc = " @param[in] pMeshObject - MeshObject instance."]
    #[doc = " @param[in] nPropertiesArrayBufferSize - Number of elements in buffer"]
    #[doc = " @param[in] pPropertiesArrayBuffer - TriangleProperties buffer of contains the triangle properties array. Must have trianglecount elements."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_meshobject_setalltriangleproperties(
        pMeshObject: Lib3MF_MeshObject,
        nPropertiesArrayBufferSize: Lib3MF_uint64,
        pPropertiesArrayBuffer: *const sLib3MFTriangleProperties,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Gets the properties of all triangles of a mesh object."]
    #[doc = ""]
    #[doc = " @param[in] pMeshObject - MeshObject instance."]
    #[doc = " @param[in] nPropertiesArrayBufferSize - Number of elements in buffer"]
    #[doc = " @param[out] pPropertiesArrayNeededCount - will be filled with the count of the written elements, or needed buffer size."]
    #[doc = " @param[out] pPropertiesArrayBuffer - TriangleProperties  buffer of returns the triangle properties array. Must have trianglecount elements."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_meshobject_getalltriangleproperties(
        pMeshObject: Lib3MF_MeshObject,
        nPropertiesArrayBufferSize: Lib3MF_uint64,
        pPropertiesArrayNeededCount: *mut Lib3MF_uint64,
        pPropertiesArrayBuffer: *mut sLib3MFTriangleProperties,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Clears all properties of this mesh object (triangle and object-level)."]
    #[doc = ""]
    #[doc = " @param[in] pMeshObject - MeshObject instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_meshobject_clearallproperties(pMeshObject: Lib3MF_MeshObject) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Set all triangles of a mesh object"]
    #[doc = ""]
    #[doc = " @param[in] pMeshObject - MeshObject instance."]
    #[doc = " @param[in] nVerticesBufferSize - Number of elements in buffer"]
    #[doc = " @param[in] pVerticesBuffer - Position buffer of contains the positions."]
    #[doc = " @param[in] nIndicesBufferSize - Number of elements in buffer"]
    #[doc = " @param[in] pIndicesBuffer - Triangle buffer of contains the triangle indices."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_meshobject_setgeometry(
        pMeshObject: Lib3MF_MeshObject,
        nVerticesBufferSize: Lib3MF_uint64,
        pVerticesBuffer: *const sLib3MFPosition,
        nIndicesBufferSize: Lib3MF_uint64,
        pIndicesBuffer: *const sLib3MFTriangle,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves, if an object describes a topologically oriented and manifold mesh, according to the core spec."]
    #[doc = ""]
    #[doc = " @param[in] pMeshObject - MeshObject instance."]
    #[doc = " @param[out] pIsManifoldAndOriented - returns, if the object is oriented and manifold."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_meshobject_ismanifoldandoriented(
        pMeshObject: Lib3MF_MeshObject,
        pIsManifoldAndOriented: *mut bool,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves the BeamLattice within this MeshObject."]
    #[doc = ""]
    #[doc = " @param[in] pMeshObject - MeshObject instance."]
    #[doc = " @param[out] pTheBeamLattice - the BeamLattice within this MeshObject"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_meshobject_beamlattice(
        pMeshObject: Lib3MF_MeshObject,
        pTheBeamLattice: *mut Lib3MF_BeamLattice,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the minimal length of beams for the beamlattice."]
    #[doc = ""]
    #[doc = " @param[in] pBeamLattice - BeamLattice instance."]
    #[doc = " @param[out] pMinLength - minimal length of beams for the beamlattice"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamlattice_getminlength(
        pBeamLattice: Lib3MF_BeamLattice,
        pMinLength: *mut Lib3MF_double,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the minimal length of beams for the beamlattice."]
    #[doc = ""]
    #[doc = " @param[in] pBeamLattice - BeamLattice instance."]
    #[doc = " @param[in] dMinLength - minimal length of beams for the beamlattice"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamlattice_setminlength(
        pBeamLattice: Lib3MF_BeamLattice,
        dMinLength: Lib3MF_double,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the clipping mode and the clipping-mesh for the beamlattice of this mesh."]
    #[doc = ""]
    #[doc = " @param[in] pBeamLattice - BeamLattice instance."]
    #[doc = " @param[out] pClipMode - contains the clip mode of this mesh"]
    #[doc = " @param[out] pUniqueResourceID - filled with the UniqueResourceID of the clipping mesh-object or an undefined value if pClipMode is MODELBEAMLATTICECLIPMODE_NONE"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamlattice_getclipping(
        pBeamLattice: Lib3MF_BeamLattice,
        pClipMode: *mut eLib3MFBeamLatticeClipMode,
        pUniqueResourceID: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the clipping mode and the clipping-mesh for the beamlattice of this mesh."]
    #[doc = ""]
    #[doc = " @param[in] pBeamLattice - BeamLattice instance."]
    #[doc = " @param[in] eClipMode - contains the clip mode of this mesh"]
    #[doc = " @param[in] nUniqueResourceID - the UniqueResourceID of the clipping mesh-object. This mesh-object has to be defined before setting the Clipping."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamlattice_setclipping(
        pBeamLattice: Lib3MF_BeamLattice,
        eClipMode: eLib3MFBeamLatticeClipMode,
        nUniqueResourceID: Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the representation-mesh for the beamlattice of this mesh."]
    #[doc = ""]
    #[doc = " @param[in] pBeamLattice - BeamLattice instance."]
    #[doc = " @param[out] pHasRepresentation - flag whether the beamlattice has a representation mesh."]
    #[doc = " @param[out] pUniqueResourceID - filled with the UniqueResourceID of the clipping mesh-object."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamlattice_getrepresentation(
        pBeamLattice: Lib3MF_BeamLattice,
        pHasRepresentation: *mut bool,
        pUniqueResourceID: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the representation-mesh for the beamlattice of this mesh."]
    #[doc = ""]
    #[doc = " @param[in] pBeamLattice - BeamLattice instance."]
    #[doc = " @param[in] nUniqueResourceID - the UniqueResourceID of the representation mesh-object. This mesh-object has to be defined before setting the representation."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamlattice_setrepresentation(
        pBeamLattice: Lib3MF_BeamLattice,
        nUniqueResourceID: Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the ball mode and the default ball radius for the beamlattice of this mesh."]
    #[doc = ""]
    #[doc = " @param[in] pBeamLattice - BeamLattice instance."]
    #[doc = " @param[out] pBallMode - contains the ball mode of this mesh"]
    #[doc = " @param[out] pBallRadius - default ball radius of balls for the beamlattice"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamlattice_getballoptions(
        pBeamLattice: Lib3MF_BeamLattice,
        pBallMode: *mut eLib3MFBeamLatticeBallMode,
        pBallRadius: *mut Lib3MF_double,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the ball mode and thedefault ball radius for the beamlattice."]
    #[doc = ""]
    #[doc = " @param[in] pBeamLattice - BeamLattice instance."]
    #[doc = " @param[in] eBallMode - contains the ball mode of this mesh"]
    #[doc = " @param[in] dBallRadius - default ball radius of balls for the beamlattice"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamlattice_setballoptions(
        pBeamLattice: Lib3MF_BeamLattice,
        eBallMode: eLib3MFBeamLatticeBallMode,
        dBallRadius: Lib3MF_double,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the beam count of a mesh object."]
    #[doc = ""]
    #[doc = " @param[in] pBeamLattice - BeamLattice instance."]
    #[doc = " @param[out] pCount - filled with the beam count."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamlattice_getbeamcount(
        pBeamLattice: Lib3MF_BeamLattice,
        pCount: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns indices, radii and capmodes of a single beam of a mesh object."]
    #[doc = ""]
    #[doc = " @param[in] pBeamLattice - BeamLattice instance."]
    #[doc = " @param[in] nIndex - Index of the beam (0 to beamcount - 1)."]
    #[doc = " @param[out] pBeamInfo - filled with the beam indices, radii and capmodes."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamlattice_getbeam(
        pBeamLattice: Lib3MF_BeamLattice,
        nIndex: Lib3MF_uint32,
        pBeamInfo: *mut sLib3MFBeam,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Adds a single beam to a mesh object."]
    #[doc = ""]
    #[doc = " @param[in] pBeamLattice - BeamLattice instance."]
    #[doc = " @param[in] pBeamInfo - contains the node indices, radii and capmodes."]
    #[doc = " @param[out] pIndex - filled with the new Index of the beam."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamlattice_addbeam(
        pBeamLattice: Lib3MF_BeamLattice,
        pBeamInfo: *const sLib3MFBeam,
        pIndex: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the indices, radii and capmodes of a single beam of a mesh object."]
    #[doc = ""]
    #[doc = " @param[in] pBeamLattice - BeamLattice instance."]
    #[doc = " @param[in] nIndex - Index of the beam (0 to beamcount - 1)."]
    #[doc = " @param[in] pBeamInfo - filled with the beam indices, radii and capmodes."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamlattice_setbeam(
        pBeamLattice: Lib3MF_BeamLattice,
        nIndex: Lib3MF_uint32,
        pBeamInfo: *const sLib3MFBeam,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets all beam indices, radii and capmodes of a mesh object."]
    #[doc = ""]
    #[doc = " @param[in] pBeamLattice - BeamLattice instance."]
    #[doc = " @param[in] nBeamInfoBufferSize - Number of elements in buffer"]
    #[doc = " @param[in] pBeamInfoBuffer - Beam buffer of contains information of a number of  beams"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamlattice_setbeams(
        pBeamLattice: Lib3MF_BeamLattice,
        nBeamInfoBufferSize: Lib3MF_uint64,
        pBeamInfoBuffer: *const sLib3MFBeam,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " obtains all beam indices, radii and capmodes of a mesh object."]
    #[doc = ""]
    #[doc = " @param[in] pBeamLattice - BeamLattice instance."]
    #[doc = " @param[in] nBeamInfoBufferSize - Number of elements in buffer"]
    #[doc = " @param[out] pBeamInfoNeededCount - will be filled with the count of the written elements, or needed buffer size."]
    #[doc = " @param[out] pBeamInfoBuffer - Beam  buffer of contains information of all beams"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamlattice_getbeams(
        pBeamLattice: Lib3MF_BeamLattice,
        nBeamInfoBufferSize: Lib3MF_uint64,
        pBeamInfoNeededCount: *mut Lib3MF_uint64,
        pBeamInfoBuffer: *mut sLib3MFBeam,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the ball count of a mesh object."]
    #[doc = ""]
    #[doc = " @param[in] pBeamLattice - BeamLattice instance."]
    #[doc = " @param[out] pCount - filled with the ball count."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamlattice_getballcount(
        pBeamLattice: Lib3MF_BeamLattice,
        pCount: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns index and radius of a single ball of a mesh object."]
    #[doc = ""]
    #[doc = " @param[in] pBeamLattice - BeamLattice instance."]
    #[doc = " @param[in] nIndex - Index of the ball (0 to ballcount - 1)."]
    #[doc = " @param[out] pBallInfo - filled with the ball node index and radius."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamlattice_getball(
        pBeamLattice: Lib3MF_BeamLattice,
        nIndex: Lib3MF_uint32,
        pBallInfo: *mut sLib3MFBall,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Adds a single ball to a mesh object."]
    #[doc = ""]
    #[doc = " @param[in] pBeamLattice - BeamLattice instance."]
    #[doc = " @param[in] pBallInfo - contains the node index and radius."]
    #[doc = " @param[out] pIndex - filled with the new Index of the ball."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamlattice_addball(
        pBeamLattice: Lib3MF_BeamLattice,
        pBallInfo: *const sLib3MFBall,
        pIndex: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the index and radius of a single ball of a mesh object."]
    #[doc = ""]
    #[doc = " @param[in] pBeamLattice - BeamLattice instance."]
    #[doc = " @param[in] nIndex - Index of the ball (0 to ballcount - 1)."]
    #[doc = " @param[in] pBallInfo - filled with the ball node index and radius."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamlattice_setball(
        pBeamLattice: Lib3MF_BeamLattice,
        nIndex: Lib3MF_uint32,
        pBallInfo: *const sLib3MFBall,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets all ball indices and radii of a mesh object."]
    #[doc = ""]
    #[doc = " @param[in] pBeamLattice - BeamLattice instance."]
    #[doc = " @param[in] nBallInfoBufferSize - Number of elements in buffer"]
    #[doc = " @param[in] pBallInfoBuffer - Ball buffer of contains information of a number of  balls"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamlattice_setballs(
        pBeamLattice: Lib3MF_BeamLattice,
        nBallInfoBufferSize: Lib3MF_uint64,
        pBallInfoBuffer: *const sLib3MFBall,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " obtains all ball indices and radii of a mesh object."]
    #[doc = ""]
    #[doc = " @param[in] pBeamLattice - BeamLattice instance."]
    #[doc = " @param[in] nBallInfoBufferSize - Number of elements in buffer"]
    #[doc = " @param[out] pBallInfoNeededCount - will be filled with the count of the written elements, or needed buffer size."]
    #[doc = " @param[out] pBallInfoBuffer - Ball  buffer of contains information of all balls"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamlattice_getballs(
        pBeamLattice: Lib3MF_BeamLattice,
        nBallInfoBufferSize: Lib3MF_uint64,
        pBallInfoNeededCount: *mut Lib3MF_uint64,
        pBallInfoBuffer: *mut sLib3MFBall,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the number of beamsets of a mesh object."]
    #[doc = ""]
    #[doc = " @param[in] pBeamLattice - BeamLattice instance."]
    #[doc = " @param[out] pCount - filled with the beamset count."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamlattice_getbeamsetcount(
        pBeamLattice: Lib3MF_BeamLattice,
        pCount: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Adds an empty beamset to a mesh object"]
    #[doc = ""]
    #[doc = " @param[in] pBeamLattice - BeamLattice instance."]
    #[doc = " @param[out] pBeamSet - the new beamset"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamlattice_addbeamset(
        pBeamLattice: Lib3MF_BeamLattice,
        pBeamSet: *mut Lib3MF_BeamSet,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns a beamset of a mesh object"]
    #[doc = ""]
    #[doc = " @param[in] pBeamLattice - BeamLattice instance."]
    #[doc = " @param[in] nIndex - index of the requested beamset (0 ... beamsetcount-1)."]
    #[doc = " @param[out] pBeamSet - the requested beamset"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamlattice_getbeamset(
        pBeamLattice: Lib3MF_BeamLattice,
        nIndex: Lib3MF_uint32,
        pBeamSet: *mut Lib3MF_BeamSet,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the Resource Instance of the component."]
    #[doc = ""]
    #[doc = " @param[in] pComponent - Component instance."]
    #[doc = " @param[out] pObjectResource - filled with the Resource Instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_component_getobjectresource(
        pComponent: Lib3MF_Component,
        pObjectResource: *mut Lib3MF_Object,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the UniqueResourceID of the component."]
    #[doc = ""]
    #[doc = " @param[in] pComponent - Component instance."]
    #[doc = " @param[out] pUniqueResourceID - returns the UniqueResourceID."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_component_getobjectresourceid(
        pComponent: Lib3MF_Component,
        pUniqueResourceID: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " returns, whether a component has a UUID and, if true, the component's UUID"]
    #[doc = ""]
    #[doc = " @param[in] pComponent - Component instance."]
    #[doc = " @param[out] pHasUUID - flag whether the component has a UUID"]
    #[doc = " @param[in] nUUIDBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pUUIDNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pUUIDBuffer -  buffer of the UUID as string of the form 'xxxxxxxx-xxxx-xxxx-xxxxxxxxxxxxxxxx', may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_component_getuuid(
        pComponent: Lib3MF_Component,
        pHasUUID: *mut bool,
        nUUIDBufferSize: Lib3MF_uint32,
        pUUIDNeededChars: *mut Lib3MF_uint32,
        pUUIDBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " sets the component's UUID"]
    #[doc = ""]
    #[doc = " @param[in] pComponent - Component instance."]
    #[doc = " @param[in] pUUID - the UUID as string of the form 'xxxxxxxx-xxxx-xxxx-xxxxxxxxxxxxxxxx'"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_component_setuuid(
        pComponent: Lib3MF_Component,
        pUUID: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns, if the component has a different transformation than the identity matrix"]
    #[doc = ""]
    #[doc = " @param[in] pComponent - Component instance."]
    #[doc = " @param[out] pHasTransform - if true is returned, the transformation is not equal than the identity"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_component_hastransform(
        pComponent: Lib3MF_Component,
        pHasTransform: *mut bool,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the transformation matrix of the component."]
    #[doc = ""]
    #[doc = " @param[in] pComponent - Component instance."]
    #[doc = " @param[out] pTransform - filled with the component transformation matrix"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_component_gettransform(
        pComponent: Lib3MF_Component,
        pTransform: *mut sLib3MFTransform,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the transformation matrix of the component."]
    #[doc = ""]
    #[doc = " @param[in] pComponent - Component instance."]
    #[doc = " @param[in] pTransform - new transformation matrix"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_component_settransform(
        pComponent: Lib3MF_Component,
        pTransform: *const sLib3MFTransform,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Adds a new component to a components object."]
    #[doc = ""]
    #[doc = " @param[in] pComponentsObject - ComponentsObject instance."]
    #[doc = " @param[in] pObjectResource - object to add as component. Must not lead to circular references!"]
    #[doc = " @param[in] pTransform - optional transform matrix for the component."]
    #[doc = " @param[out] pComponentInstance - new component instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_componentsobject_addcomponent(
        pComponentsObject: Lib3MF_ComponentsObject,
        pObjectResource: Lib3MF_Object,
        pTransform: *const sLib3MFTransform,
        pComponentInstance: *mut Lib3MF_Component,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves a component from a component object."]
    #[doc = ""]
    #[doc = " @param[in] pComponentsObject - ComponentsObject instance."]
    #[doc = " @param[in] nIndex - index of the component to retrieve (0 to componentcount - 1)"]
    #[doc = " @param[out] pComponentInstance - component instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_componentsobject_getcomponent(
        pComponentsObject: Lib3MF_ComponentsObject,
        nIndex: Lib3MF_uint32,
        pComponentInstance: *mut Lib3MF_Component,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves a component count of a component object."]
    #[doc = ""]
    #[doc = " @param[in] pComponentsObject - ComponentsObject instance."]
    #[doc = " @param[out] pCount - returns the component count"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_componentsobject_getcomponentcount(
        pComponentsObject: Lib3MF_ComponentsObject,
        pCount: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets a beamset's name string"]
    #[doc = ""]
    #[doc = " @param[in] pBeamSet - BeamSet instance."]
    #[doc = " @param[in] pName - new name of the beamset."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamset_setname(
        pBeamSet: Lib3MF_BeamSet,
        pName: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves a beamset's name string"]
    #[doc = ""]
    #[doc = " @param[in] pBeamSet - BeamSet instance."]
    #[doc = " @param[in] nNameBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pNameNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pNameBuffer -  buffer of returns the name of the beamset., may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamset_getname(
        pBeamSet: Lib3MF_BeamSet,
        nNameBufferSize: Lib3MF_uint32,
        pNameNeededChars: *mut Lib3MF_uint32,
        pNameBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets a beamset's identifier string"]
    #[doc = ""]
    #[doc = " @param[in] pBeamSet - BeamSet instance."]
    #[doc = " @param[in] pIdentifier - new name of the beamset."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamset_setidentifier(
        pBeamSet: Lib3MF_BeamSet,
        pIdentifier: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves a beamset's identifier string"]
    #[doc = ""]
    #[doc = " @param[in] pBeamSet - BeamSet instance."]
    #[doc = " @param[in] nIdentifierBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pIdentifierNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pIdentifierBuffer -  buffer of returns the identifier of the beamset., may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamset_getidentifier(
        pBeamSet: Lib3MF_BeamSet,
        nIdentifierBufferSize: Lib3MF_uint32,
        pIdentifierNeededChars: *mut Lib3MF_uint32,
        pIdentifierBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves the reference count of a beamset"]
    #[doc = ""]
    #[doc = " @param[in] pBeamSet - BeamSet instance."]
    #[doc = " @param[out] pCount - returns the reference count"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamset_getreferencecount(
        pBeamSet: Lib3MF_BeamSet,
        pCount: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the references of a beamset"]
    #[doc = ""]
    #[doc = " @param[in] pBeamSet - BeamSet instance."]
    #[doc = " @param[in] nReferencesBufferSize - Number of elements in buffer"]
    #[doc = " @param[in] pReferencesBuffer - uint32 buffer of the new indices of all beams in this beamset"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamset_setreferences(
        pBeamSet: Lib3MF_BeamSet,
        nReferencesBufferSize: Lib3MF_uint64,
        pReferencesBuffer: *const Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves the references of a beamset"]
    #[doc = ""]
    #[doc = " @param[in] pBeamSet - BeamSet instance."]
    #[doc = " @param[in] nReferencesBufferSize - Number of elements in buffer"]
    #[doc = " @param[out] pReferencesNeededCount - will be filled with the count of the written elements, or needed buffer size."]
    #[doc = " @param[out] pReferencesBuffer - uint32  buffer of retrieves the indices of all beams in this beamset"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamset_getreferences(
        pBeamSet: Lib3MF_BeamSet,
        nReferencesBufferSize: Lib3MF_uint64,
        pReferencesNeededCount: *mut Lib3MF_uint64,
        pReferencesBuffer: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves the ball reference count of a beamset"]
    #[doc = ""]
    #[doc = " @param[in] pBeamSet - BeamSet instance."]
    #[doc = " @param[out] pCount - returns the ball reference count"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamset_getballreferencecount(
        pBeamSet: Lib3MF_BeamSet,
        pCount: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the ball references of a beamset"]
    #[doc = ""]
    #[doc = " @param[in] pBeamSet - BeamSet instance."]
    #[doc = " @param[in] nBallReferencesBufferSize - Number of elements in buffer"]
    #[doc = " @param[in] pBallReferencesBuffer - uint32 buffer of the new indices of all balls in this beamset"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamset_setballreferences(
        pBeamSet: Lib3MF_BeamSet,
        nBallReferencesBufferSize: Lib3MF_uint64,
        pBallReferencesBuffer: *const Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves the ball references of a beamset"]
    #[doc = ""]
    #[doc = " @param[in] pBeamSet - BeamSet instance."]
    #[doc = " @param[in] nBallReferencesBufferSize - Number of elements in buffer"]
    #[doc = " @param[out] pBallReferencesNeededCount - will be filled with the count of the written elements, or needed buffer size."]
    #[doc = " @param[out] pBallReferencesBuffer - uint32  buffer of retrieves the indices of all balls in this beamset"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_beamset_getballreferences(
        pBeamSet: Lib3MF_BeamSet,
        nBallReferencesBufferSize: Lib3MF_uint64,
        pBallReferencesNeededCount: *mut Lib3MF_uint64,
        pBallReferencesBuffer: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves the count of base materials in the material group."]
    #[doc = ""]
    #[doc = " @param[in] pBaseMaterialGroup - BaseMaterialGroup instance."]
    #[doc = " @param[out] pCount - returns the count of base materials."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_basematerialgroup_getcount(
        pBaseMaterialGroup: Lib3MF_BaseMaterialGroup,
        pCount: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " returns all the PropertyIDs of all materials in this group"]
    #[doc = ""]
    #[doc = " @param[in] pBaseMaterialGroup - BaseMaterialGroup instance."]
    #[doc = " @param[in] nPropertyIDsBufferSize - Number of elements in buffer"]
    #[doc = " @param[out] pPropertyIDsNeededCount - will be filled with the count of the written elements, or needed buffer size."]
    #[doc = " @param[out] pPropertyIDsBuffer - uint32  buffer of PropertyID of the material in the material group."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_basematerialgroup_getallpropertyids(
        pBaseMaterialGroup: Lib3MF_BaseMaterialGroup,
        nPropertyIDsBufferSize: Lib3MF_uint64,
        pPropertyIDsNeededCount: *mut Lib3MF_uint64,
        pPropertyIDsBuffer: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Adds a new material to the material group"]
    #[doc = ""]
    #[doc = " @param[in] pBaseMaterialGroup - BaseMaterialGroup instance."]
    #[doc = " @param[in] pName - new name of the base material."]
    #[doc = " @param[in] pDisplayColor - Display color of the material"]
    #[doc = " @param[out] pPropertyID - returns new PropertyID of the new material in the material group."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_basematerialgroup_addmaterial(
        pBaseMaterialGroup: Lib3MF_BaseMaterialGroup,
        pName: *const ::std::os::raw::c_char,
        pDisplayColor: *const sLib3MFColor,
        pPropertyID: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Removes a material from the material group."]
    #[doc = ""]
    #[doc = " @param[in] pBaseMaterialGroup - BaseMaterialGroup instance."]
    #[doc = " @param[in] nPropertyID - PropertyID of the material in the material group."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_basematerialgroup_removematerial(
        pBaseMaterialGroup: Lib3MF_BaseMaterialGroup,
        nPropertyID: Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the base material's name"]
    #[doc = ""]
    #[doc = " @param[in] pBaseMaterialGroup - BaseMaterialGroup instance."]
    #[doc = " @param[in] nPropertyID - PropertyID of the material in the material group."]
    #[doc = " @param[in] nNameBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pNameNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pNameBuffer -  buffer of returns the name of the base material., may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_basematerialgroup_getname(
        pBaseMaterialGroup: Lib3MF_BaseMaterialGroup,
        nPropertyID: Lib3MF_uint32,
        nNameBufferSize: Lib3MF_uint32,
        pNameNeededChars: *mut Lib3MF_uint32,
        pNameBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets a base material's name"]
    #[doc = ""]
    #[doc = " @param[in] pBaseMaterialGroup - BaseMaterialGroup instance."]
    #[doc = " @param[in] nPropertyID - PropertyID of the material in the material group."]
    #[doc = " @param[in] pName - new name of the base material."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_basematerialgroup_setname(
        pBaseMaterialGroup: Lib3MF_BaseMaterialGroup,
        nPropertyID: Lib3MF_uint32,
        pName: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets a base material's display color."]
    #[doc = ""]
    #[doc = " @param[in] pBaseMaterialGroup - BaseMaterialGroup instance."]
    #[doc = " @param[in] nPropertyID - PropertyID of the material in the material group."]
    #[doc = " @param[in] pTheColor - The base material's display color"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_basematerialgroup_setdisplaycolor(
        pBaseMaterialGroup: Lib3MF_BaseMaterialGroup,
        nPropertyID: Lib3MF_uint32,
        pTheColor: *const sLib3MFColor,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns a base material's display color."]
    #[doc = ""]
    #[doc = " @param[in] pBaseMaterialGroup - BaseMaterialGroup instance."]
    #[doc = " @param[in] nPropertyID - PropertyID of the material in the material group."]
    #[doc = " @param[out] pTheColor - The base material's display color"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_basematerialgroup_getdisplaycolor(
        pBaseMaterialGroup: Lib3MF_BaseMaterialGroup,
        nPropertyID: Lib3MF_uint32,
        pTheColor: *mut sLib3MFColor,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves the count of base materials in this Color Group."]
    #[doc = ""]
    #[doc = " @param[in] pColorGroup - ColorGroup instance."]
    #[doc = " @param[out] pCount - returns the count of colors within this color group."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_colorgroup_getcount(
        pColorGroup: Lib3MF_ColorGroup,
        pCount: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " returns all the PropertyIDs of all colors within this group"]
    #[doc = ""]
    #[doc = " @param[in] pColorGroup - ColorGroup instance."]
    #[doc = " @param[in] nPropertyIDsBufferSize - Number of elements in buffer"]
    #[doc = " @param[out] pPropertyIDsNeededCount - will be filled with the count of the written elements, or needed buffer size."]
    #[doc = " @param[out] pPropertyIDsBuffer - uint32  buffer of PropertyID of the color in the color group."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_colorgroup_getallpropertyids(
        pColorGroup: Lib3MF_ColorGroup,
        nPropertyIDsBufferSize: Lib3MF_uint64,
        pPropertyIDsNeededCount: *mut Lib3MF_uint64,
        pPropertyIDsBuffer: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Adds a new value."]
    #[doc = ""]
    #[doc = " @param[in] pColorGroup - ColorGroup instance."]
    #[doc = " @param[in] pTheColor - The new color"]
    #[doc = " @param[out] pPropertyID - PropertyID of the new color within this color group."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_colorgroup_addcolor(
        pColorGroup: Lib3MF_ColorGroup,
        pTheColor: *const sLib3MFColor,
        pPropertyID: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Removes a color from the color group."]
    #[doc = ""]
    #[doc = " @param[in] pColorGroup - ColorGroup instance."]
    #[doc = " @param[in] nPropertyID - PropertyID of the color to be removed from the color group."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_colorgroup_removecolor(
        pColorGroup: Lib3MF_ColorGroup,
        nPropertyID: Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets a color value."]
    #[doc = ""]
    #[doc = " @param[in] pColorGroup - ColorGroup instance."]
    #[doc = " @param[in] nPropertyID - PropertyID of a color within this color group."]
    #[doc = " @param[in] pTheColor - The color"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_colorgroup_setcolor(
        pColorGroup: Lib3MF_ColorGroup,
        nPropertyID: Lib3MF_uint32,
        pTheColor: *const sLib3MFColor,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets a color value."]
    #[doc = ""]
    #[doc = " @param[in] pColorGroup - ColorGroup instance."]
    #[doc = " @param[in] nPropertyID - PropertyID of a color within this color group."]
    #[doc = " @param[out] pTheColor - The color"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_colorgroup_getcolor(
        pColorGroup: Lib3MF_ColorGroup,
        nPropertyID: Lib3MF_uint32,
        pTheColor: *mut sLib3MFColor,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves the count of tex2coords in the Texture2DGroup."]
    #[doc = ""]
    #[doc = " @param[in] pTexture2DGroup - Texture2DGroup instance."]
    #[doc = " @param[out] pCount - returns the count of tex2coords."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_texture2dgroup_getcount(
        pTexture2DGroup: Lib3MF_Texture2DGroup,
        pCount: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " returns all the PropertyIDs of all tex2coords in this Texture2DGroup"]
    #[doc = ""]
    #[doc = " @param[in] pTexture2DGroup - Texture2DGroup instance."]
    #[doc = " @param[in] nPropertyIDsBufferSize - Number of elements in buffer"]
    #[doc = " @param[out] pPropertyIDsNeededCount - will be filled with the count of the written elements, or needed buffer size."]
    #[doc = " @param[out] pPropertyIDsBuffer - uint32  buffer of PropertyID of the tex2coords in the Texture2DGroup."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_texture2dgroup_getallpropertyids(
        pTexture2DGroup: Lib3MF_Texture2DGroup,
        nPropertyIDsBufferSize: Lib3MF_uint64,
        pPropertyIDsNeededCount: *mut Lib3MF_uint64,
        pPropertyIDsBuffer: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Adds a new tex2coord to the Texture2DGroup"]
    #[doc = ""]
    #[doc = " @param[in] pTexture2DGroup - Texture2DGroup instance."]
    #[doc = " @param[in] pUVCoordinate - The u/v-coordinate within the texture, horizontally right/vertically up from the origin in the lower left of the texture."]
    #[doc = " @param[out] pPropertyID - returns new PropertyID of the new tex2coord in the Texture2DGroup."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_texture2dgroup_addtex2coord(
        pTexture2DGroup: Lib3MF_Texture2DGroup,
        pUVCoordinate: *const sLib3MFTex2Coord,
        pPropertyID: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Obtains a tex2coord to the Texture2DGroup"]
    #[doc = ""]
    #[doc = " @param[in] pTexture2DGroup - Texture2DGroup instance."]
    #[doc = " @param[in] nPropertyID - the PropertyID of the tex2coord in the Texture2DGroup."]
    #[doc = " @param[out] pUVCoordinate - The u/v-coordinate within the texture, horizontally right/vertically up from the origin in the lower left of the texture."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_texture2dgroup_gettex2coord(
        pTexture2DGroup: Lib3MF_Texture2DGroup,
        nPropertyID: Lib3MF_uint32,
        pUVCoordinate: *mut sLib3MFTex2Coord,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Removes a tex2coords from the Texture2DGroup."]
    #[doc = ""]
    #[doc = " @param[in] pTexture2DGroup - Texture2DGroup instance."]
    #[doc = " @param[in] nPropertyID - PropertyID of the tex2coords in the Texture2DGroup."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_texture2dgroup_removetex2coord(
        pTexture2DGroup: Lib3MF_Texture2DGroup,
        nPropertyID: Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Obtains the texture2D instance of this group."]
    #[doc = ""]
    #[doc = " @param[in] pTexture2DGroup - Texture2DGroup instance."]
    #[doc = " @param[out] pTexture2DInstance - the texture2D instance of this group."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_texture2dgroup_gettexture2d(
        pTexture2DGroup: Lib3MF_Texture2DGroup,
        pTexture2DInstance: *mut Lib3MF_Texture2D,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves the count of Composite-s in the CompositeMaterials."]
    #[doc = ""]
    #[doc = " @param[in] pCompositeMaterials - CompositeMaterials instance."]
    #[doc = " @param[out] pCount - returns the count of Composite-s"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_compositematerials_getcount(
        pCompositeMaterials: Lib3MF_CompositeMaterials,
        pCount: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " returns all the PropertyIDs of all Composite-Mixing Values in this CompositeMaterials"]
    #[doc = ""]
    #[doc = " @param[in] pCompositeMaterials - CompositeMaterials instance."]
    #[doc = " @param[in] nPropertyIDsBufferSize - Number of elements in buffer"]
    #[doc = " @param[out] pPropertyIDsNeededCount - will be filled with the count of the written elements, or needed buffer size."]
    #[doc = " @param[out] pPropertyIDsBuffer - uint32  buffer of PropertyID of the Composite-Mixing Values in the CompositeMaterials."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_compositematerials_getallpropertyids(
        pCompositeMaterials: Lib3MF_CompositeMaterials,
        nPropertyIDsBufferSize: Lib3MF_uint64,
        pPropertyIDsNeededCount: *mut Lib3MF_uint64,
        pPropertyIDsBuffer: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Obtains the BaseMaterialGroup instance of this CompositeMaterials."]
    #[doc = ""]
    #[doc = " @param[in] pCompositeMaterials - CompositeMaterials instance."]
    #[doc = " @param[out] pBaseMaterialGroupInstance - returns the BaseMaterialGroup instance of this CompositeMaterials"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_compositematerials_getbasematerialgroup(
        pCompositeMaterials: Lib3MF_CompositeMaterials,
        pBaseMaterialGroupInstance: *mut Lib3MF_BaseMaterialGroup,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Adds a new Composite-Mixing Values to the CompositeMaterials."]
    #[doc = ""]
    #[doc = " @param[in] pCompositeMaterials - CompositeMaterials instance."]
    #[doc = " @param[in] nCompositeBufferSize - Number of elements in buffer"]
    #[doc = " @param[in] pCompositeBuffer - CompositeConstituent buffer of The Composite Constituents to be added as composite"]
    #[doc = " @param[out] pPropertyID - returns new PropertyID of the new Composite in the CompositeMaterials."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_compositematerials_addcomposite(
        pCompositeMaterials: Lib3MF_CompositeMaterials,
        nCompositeBufferSize: Lib3MF_uint64,
        pCompositeBuffer: *const sLib3MFCompositeConstituent,
        pPropertyID: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Removes a Composite-Maxing Ratio from the CompositeMaterials."]
    #[doc = ""]
    #[doc = " @param[in] pCompositeMaterials - CompositeMaterials instance."]
    #[doc = " @param[in] nPropertyID - PropertyID of the  Composite-Mixing Values in the CompositeMaterials to be removed."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_compositematerials_removecomposite(
        pCompositeMaterials: Lib3MF_CompositeMaterials,
        nPropertyID: Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Obtains a Composite-Maxing Ratio of this CompositeMaterials."]
    #[doc = ""]
    #[doc = " @param[in] pCompositeMaterials - CompositeMaterials instance."]
    #[doc = " @param[in] nPropertyID - the PropertyID of the Composite-Maxing Ratio in the CompositeMaterials."]
    #[doc = " @param[in] nCompositeBufferSize - Number of elements in buffer"]
    #[doc = " @param[out] pCompositeNeededCount - will be filled with the count of the written elements, or needed buffer size."]
    #[doc = " @param[out] pCompositeBuffer - CompositeConstituent  buffer of The Composite-Mixing Values with the given PropertyID"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_compositematerials_getcomposite(
        pCompositeMaterials: Lib3MF_CompositeMaterials,
        nPropertyID: Lib3MF_uint32,
        nCompositeBufferSize: Lib3MF_uint64,
        pCompositeNeededCount: *mut Lib3MF_uint64,
        pCompositeBuffer: *mut sLib3MFCompositeConstituent,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves the count of MultiProperty-s in the MultiPropertyGroup."]
    #[doc = ""]
    #[doc = " @param[in] pMultiPropertyGroup - MultiPropertyGroup instance."]
    #[doc = " @param[out] pCount - returns the count of MultiProperty-s"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_multipropertygroup_getcount(
        pMultiPropertyGroup: Lib3MF_MultiPropertyGroup,
        pCount: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " returns all the PropertyIDs of all MultiProperty-s in this MultiPropertyGroup"]
    #[doc = ""]
    #[doc = " @param[in] pMultiPropertyGroup - MultiPropertyGroup instance."]
    #[doc = " @param[in] nPropertyIDsBufferSize - Number of elements in buffer"]
    #[doc = " @param[out] pPropertyIDsNeededCount - will be filled with the count of the written elements, or needed buffer size."]
    #[doc = " @param[out] pPropertyIDsBuffer - uint32  buffer of PropertyID of the MultiProperty-s in the MultiPropertyGroup."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_multipropertygroup_getallpropertyids(
        pMultiPropertyGroup: Lib3MF_MultiPropertyGroup,
        nPropertyIDsBufferSize: Lib3MF_uint64,
        pPropertyIDsNeededCount: *mut Lib3MF_uint64,
        pPropertyIDsBuffer: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Adds a new MultiProperty to the MultiPropertyGroup."]
    #[doc = ""]
    #[doc = " @param[in] pMultiPropertyGroup - MultiPropertyGroup instance."]
    #[doc = " @param[in] nPropertyIDsBufferSize - Number of elements in buffer"]
    #[doc = " @param[in] pPropertyIDsBuffer - uint32 buffer of The PropertyIDs of the new MultiProperty."]
    #[doc = " @param[out] pPropertyID - returns the PropertyID of the new MultiProperty in the MultiPropertyGroup."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_multipropertygroup_addmultiproperty(
        pMultiPropertyGroup: Lib3MF_MultiPropertyGroup,
        nPropertyIDsBufferSize: Lib3MF_uint64,
        pPropertyIDsBuffer: *const Lib3MF_uint32,
        pPropertyID: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the PropertyIDs of a MultiProperty."]
    #[doc = ""]
    #[doc = " @param[in] pMultiPropertyGroup - MultiPropertyGroup instance."]
    #[doc = " @param[in] nPropertyID - the PropertyID of the MultiProperty to be changed."]
    #[doc = " @param[in] nPropertyIDsBufferSize - Number of elements in buffer"]
    #[doc = " @param[in] pPropertyIDsBuffer - uint32 buffer of The new PropertyIDs of the MultiProperty"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_multipropertygroup_setmultiproperty(
        pMultiPropertyGroup: Lib3MF_MultiPropertyGroup,
        nPropertyID: Lib3MF_uint32,
        nPropertyIDsBufferSize: Lib3MF_uint64,
        pPropertyIDsBuffer: *const Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Obtains the PropertyIDs of a MultiProperty."]
    #[doc = ""]
    #[doc = " @param[in] pMultiPropertyGroup - MultiPropertyGroup instance."]
    #[doc = " @param[in] nPropertyID - the PropertyID of the MultiProperty to be queried."]
    #[doc = " @param[in] nPropertyIDsBufferSize - Number of elements in buffer"]
    #[doc = " @param[out] pPropertyIDsNeededCount - will be filled with the count of the written elements, or needed buffer size."]
    #[doc = " @param[out] pPropertyIDsBuffer - uint32  buffer of The PropertyIDs of the MultiProperty"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_multipropertygroup_getmultiproperty(
        pMultiPropertyGroup: Lib3MF_MultiPropertyGroup,
        nPropertyID: Lib3MF_uint32,
        nPropertyIDsBufferSize: Lib3MF_uint64,
        pPropertyIDsNeededCount: *mut Lib3MF_uint64,
        pPropertyIDsBuffer: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Removes a MultiProperty from this MultiPropertyGroup."]
    #[doc = ""]
    #[doc = " @param[in] pMultiPropertyGroup - MultiPropertyGroup instance."]
    #[doc = " @param[in] nPropertyID - the PropertyID of the MultiProperty to be removed."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_multipropertygroup_removemultiproperty(
        pMultiPropertyGroup: Lib3MF_MultiPropertyGroup,
        nPropertyID: Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves the number of layers of this MultiPropertyGroup."]
    #[doc = ""]
    #[doc = " @param[in] pMultiPropertyGroup - MultiPropertyGroup instance."]
    #[doc = " @param[out] pCount - returns the number of layers"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_multipropertygroup_getlayercount(
        pMultiPropertyGroup: Lib3MF_MultiPropertyGroup,
        pCount: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Adds a MultiPropertyLayer to this MultiPropertyGroup."]
    #[doc = ""]
    #[doc = " @param[in] pMultiPropertyGroup - MultiPropertyGroup instance."]
    #[doc = " @param[in] pTheLayer - The MultiPropertyLayer to add to this MultiPropertyGroup"]
    #[doc = " @param[out] pLayerIndex - returns the index of this MultiPropertyLayer"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_multipropertygroup_addlayer(
        pMultiPropertyGroup: Lib3MF_MultiPropertyGroup,
        pTheLayer: *const sLib3MFMultiPropertyLayer,
        pLayerIndex: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Obtains a MultiPropertyLayer of this MultiPropertyGroup."]
    #[doc = ""]
    #[doc = " @param[in] pMultiPropertyGroup - MultiPropertyGroup instance."]
    #[doc = " @param[in] nLayerIndex - The Index of the MultiPropertyLayer queried"]
    #[doc = " @param[out] pTheLayer - The MultiPropertyLayer with index LayerIndex within MultiPropertyGroup"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_multipropertygroup_getlayer(
        pMultiPropertyGroup: Lib3MF_MultiPropertyGroup,
        nLayerIndex: Lib3MF_uint32,
        pTheLayer: *mut sLib3MFMultiPropertyLayer,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Removes a MultiPropertyLayer from this MultiPropertyGroup."]
    #[doc = ""]
    #[doc = " @param[in] pMultiPropertyGroup - MultiPropertyGroup instance."]
    #[doc = " @param[in] nLayerIndex - The Index of the MultiPropertyLayer to be removed"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_multipropertygroup_removelayer(
        pMultiPropertyGroup: Lib3MF_MultiPropertyGroup,
        nLayerIndex: Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves an attachment's package path. This function will be removed in a later release."]
    #[doc = ""]
    #[doc = " @param[in] pAttachment - Attachment instance."]
    #[doc = " @param[in] nPathBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pPathNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pPathBuffer -  buffer of returns the attachment's package path string, may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_attachment_getpath(
        pAttachment: Lib3MF_Attachment,
        nPathBufferSize: Lib3MF_uint32,
        pPathNeededChars: *mut Lib3MF_uint32,
        pPathBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets an attachment's package path. This function will be removed in a later release."]
    #[doc = ""]
    #[doc = " @param[in] pAttachment - Attachment instance."]
    #[doc = " @param[in] pPath - new path of the attachment."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_attachment_setpath(
        pAttachment: Lib3MF_Attachment,
        pPath: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the PackagePart that is this attachment."]
    #[doc = ""]
    #[doc = " @param[in] pAttachment - Attachment instance."]
    #[doc = " @param[out] pPackagePart - The PackagePart of this attachment."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_attachment_packagepart(
        pAttachment: Lib3MF_Attachment,
        pPackagePart: *mut Lib3MF_PackagePart,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves an attachment's relationship type"]
    #[doc = ""]
    #[doc = " @param[in] pAttachment - Attachment instance."]
    #[doc = " @param[in] nPathBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pPathNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pPathBuffer -  buffer of returns the attachment's package relationship type string, may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_attachment_getrelationshiptype(
        pAttachment: Lib3MF_Attachment,
        nPathBufferSize: Lib3MF_uint32,
        pPathNeededChars: *mut Lib3MF_uint32,
        pPathBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets an attachment's relationship type."]
    #[doc = ""]
    #[doc = " @param[in] pAttachment - Attachment instance."]
    #[doc = " @param[in] pPath - new relationship type string."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_attachment_setrelationshiptype(
        pAttachment: Lib3MF_Attachment,
        pPath: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Writes out the attachment as file."]
    #[doc = ""]
    #[doc = " @param[in] pAttachment - Attachment instance."]
    #[doc = " @param[in] pFileName - file to write into."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_attachment_writetofile(
        pAttachment: Lib3MF_Attachment,
        pFileName: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Reads an attachment from a file. The path of this file is only read when this attachment is being written as part of the 3MF packege, or via the WriteToFile or WriteToBuffer-methods."]
    #[doc = ""]
    #[doc = " @param[in] pAttachment - Attachment instance."]
    #[doc = " @param[in] pFileName - file to read from."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_attachment_readfromfile(
        pAttachment: Lib3MF_Attachment,
        pFileName: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Reads a model and from the data provided by a callback function"]
    #[doc = ""]
    #[doc = " @param[in] pAttachment - Attachment instance."]
    #[doc = " @param[in] pTheReadCallback - Callback to call for reading a data chunk"]
    #[doc = " @param[in] nStreamSize - number of bytes the callback returns"]
    #[doc = " @param[in] pTheSeekCallback - Callback to call for seeking in the stream."]
    #[doc = " @param[in] pUserData - Userdata that is passed to the callback function"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_attachment_readfromcallback(
        pAttachment: Lib3MF_Attachment,
        pTheReadCallback: Lib3MFReadCallback,
        nStreamSize: Lib3MF_uint64,
        pTheSeekCallback: Lib3MFSeekCallback,
        pUserData: Lib3MF_pvoid,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves the size of the attachment stream"]
    #[doc = ""]
    #[doc = " @param[in] pAttachment - Attachment instance."]
    #[doc = " @param[out] pStreamSize - the stream size"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_attachment_getstreamsize(
        pAttachment: Lib3MF_Attachment,
        pStreamSize: *mut Lib3MF_uint64,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Writes out the attachment into a buffer"]
    #[doc = ""]
    #[doc = " @param[in] pAttachment - Attachment instance."]
    #[doc = " @param[in] nBufferBufferSize - Number of elements in buffer"]
    #[doc = " @param[out] pBufferNeededCount - will be filled with the count of the written elements, or needed buffer size."]
    #[doc = " @param[out] pBufferBuffer - uint8  buffer of Buffer to write into"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_attachment_writetobuffer(
        pAttachment: Lib3MF_Attachment,
        nBufferBufferSize: Lib3MF_uint64,
        pBufferNeededCount: *mut Lib3MF_uint64,
        pBufferBuffer: *mut Lib3MF_uint8,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Reads an attachment from a memory buffer"]
    #[doc = ""]
    #[doc = " @param[in] pAttachment - Attachment instance."]
    #[doc = " @param[in] nBufferBufferSize - Number of elements in buffer"]
    #[doc = " @param[in] pBufferBuffer - uint8 buffer of Buffer to read from"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_attachment_readfrombuffer(
        pAttachment: Lib3MF_Attachment,
        nBufferBufferSize: Lib3MF_uint64,
        pBufferBuffer: *const Lib3MF_uint8,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves the attachment located at the path of the texture."]
    #[doc = ""]
    #[doc = " @param[in] pTexture2D - Texture2D instance."]
    #[doc = " @param[out] pAttachment - attachment that holds the texture's image information."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_texture2d_getattachment(
        pTexture2D: Lib3MF_Texture2D,
        pAttachment: *mut Lib3MF_Attachment,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the texture's package path to the path of the attachment."]
    #[doc = ""]
    #[doc = " @param[in] pTexture2D - Texture2D instance."]
    #[doc = " @param[in] pAttachment - attachment that holds the texture's image information."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_texture2d_setattachment(
        pTexture2D: Lib3MF_Texture2D,
        pAttachment: Lib3MF_Attachment,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves a texture's content type."]
    #[doc = ""]
    #[doc = " @param[in] pTexture2D - Texture2D instance."]
    #[doc = " @param[out] pContentType - returns content type enum."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_texture2d_getcontenttype(
        pTexture2D: Lib3MF_Texture2D,
        pContentType: *mut eLib3MFTextureType,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves a texture's content type."]
    #[doc = ""]
    #[doc = " @param[in] pTexture2D - Texture2D instance."]
    #[doc = " @param[in] eContentType - new Content Type"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_texture2d_setcontenttype(
        pTexture2D: Lib3MF_Texture2D,
        eContentType: eLib3MFTextureType,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves a texture's tilestyle type."]
    #[doc = ""]
    #[doc = " @param[in] pTexture2D - Texture2D instance."]
    #[doc = " @param[out] pTileStyleU - returns tilestyle type enum."]
    #[doc = " @param[out] pTileStyleV - returns tilestyle type enum."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_texture2d_gettilestyleuv(
        pTexture2D: Lib3MF_Texture2D,
        pTileStyleU: *mut eLib3MFTextureTileStyle,
        pTileStyleV: *mut eLib3MFTextureTileStyle,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets a texture's tilestyle type."]
    #[doc = ""]
    #[doc = " @param[in] pTexture2D - Texture2D instance."]
    #[doc = " @param[in] eTileStyleU - new tilestyle type enum."]
    #[doc = " @param[in] eTileStyleV - new tilestyle type enum."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_texture2d_settilestyleuv(
        pTexture2D: Lib3MF_Texture2D,
        eTileStyleU: eLib3MFTextureTileStyle,
        eTileStyleV: eLib3MFTextureTileStyle,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves a texture's filter type."]
    #[doc = ""]
    #[doc = " @param[in] pTexture2D - Texture2D instance."]
    #[doc = " @param[out] pFilter - returns filter type enum."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_texture2d_getfilter(
        pTexture2D: Lib3MF_Texture2D,
        pFilter: *mut eLib3MFTextureFilter,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets a texture's filter type."]
    #[doc = ""]
    #[doc = " @param[in] pTexture2D - Texture2D instance."]
    #[doc = " @param[in] eFilter - sets new filter type enum."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_texture2d_setfilter(
        pTexture2D: Lib3MF_Texture2D,
        eFilter: eLib3MFTextureFilter,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves the object resource associated to a build item"]
    #[doc = ""]
    #[doc = " @param[in] pBuildItem - BuildItem instance."]
    #[doc = " @param[out] pObjectResource - returns the associated resource instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_builditem_getobjectresource(
        pBuildItem: Lib3MF_BuildItem,
        pObjectResource: *mut Lib3MF_Object,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " returns, whether a build item has a UUID and, if true, the build item's UUID"]
    #[doc = ""]
    #[doc = " @param[in] pBuildItem - BuildItem instance."]
    #[doc = " @param[out] pHasUUID - flag whether the build item has a UUID"]
    #[doc = " @param[in] nUUIDBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pUUIDNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pUUIDBuffer -  buffer of the UUID as string of the form 'xxxxxxxx-xxxx-xxxx-xxxxxxxxxxxxxxxx', may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_builditem_getuuid(
        pBuildItem: Lib3MF_BuildItem,
        pHasUUID: *mut bool,
        nUUIDBufferSize: Lib3MF_uint32,
        pUUIDNeededChars: *mut Lib3MF_uint32,
        pUUIDBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " sets the build item's UUID"]
    #[doc = ""]
    #[doc = " @param[in] pBuildItem - BuildItem instance."]
    #[doc = " @param[in] pUUID - the UUID as string of the form 'xxxxxxxx-xxxx-xxxx-xxxxxxxxxxxxxxxx'"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_builditem_setuuid(
        pBuildItem: Lib3MF_BuildItem,
        pUUID: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves the object UniqueResourceID associated to a build item"]
    #[doc = ""]
    #[doc = " @param[in] pBuildItem - BuildItem instance."]
    #[doc = " @param[out] pUniqueResourceID - returns the UniqueResourceID of the object"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_builditem_getobjectresourceid(
        pBuildItem: Lib3MF_BuildItem,
        pUniqueResourceID: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Checks, if a build item has a non-identity transformation matrix"]
    #[doc = ""]
    #[doc = " @param[in] pBuildItem - BuildItem instance."]
    #[doc = " @param[out] pHasTransform - returns true, if the transformation matrix is not the identity"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_builditem_hasobjecttransform(
        pBuildItem: Lib3MF_BuildItem,
        pHasTransform: *mut bool,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves a build item's transformation matrix."]
    #[doc = ""]
    #[doc = " @param[in] pBuildItem - BuildItem instance."]
    #[doc = " @param[out] pTransform - returns the transformation matrix"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_builditem_getobjecttransform(
        pBuildItem: Lib3MF_BuildItem,
        pTransform: *mut sLib3MFTransform,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets a build item's transformation matrix."]
    #[doc = ""]
    #[doc = " @param[in] pBuildItem - BuildItem instance."]
    #[doc = " @param[in] pTransform - new transformation matrix"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_builditem_setobjecttransform(
        pBuildItem: Lib3MF_BuildItem,
        pTransform: *const sLib3MFTransform,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves a build item's part number string"]
    #[doc = ""]
    #[doc = " @param[in] pBuildItem - BuildItem instance."]
    #[doc = " @param[in] nPartNumberBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pPartNumberNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pPartNumberBuffer -  buffer of Returns a build item's part number string, may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_builditem_getpartnumber(
        pBuildItem: Lib3MF_BuildItem,
        nPartNumberBufferSize: Lib3MF_uint32,
        pPartNumberNeededChars: *mut Lib3MF_uint32,
        pPartNumberBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets a build item's part number string"]
    #[doc = ""]
    #[doc = " @param[in] pBuildItem - BuildItem instance."]
    #[doc = " @param[in] pSetPartnumber - new part number string for referencing parts from the outside world"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_builditem_setpartnumber(
        pBuildItem: Lib3MF_BuildItem,
        pSetPartnumber: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the metadatagroup of this build item"]
    #[doc = ""]
    #[doc = " @param[in] pBuildItem - BuildItem instance."]
    #[doc = " @param[out] pMetaDataGroup - returns an Instance of the metadatagroup of this build item"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_builditem_getmetadatagroup(
        pBuildItem: Lib3MF_BuildItem,
        pMetaDataGroup: *mut Lib3MF_MetaDataGroup,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the outbox of a build item"]
    #[doc = ""]
    #[doc = " @param[in] pBuildItem - BuildItem instance."]
    #[doc = " @param[out] pOutbox - Outbox of this build item"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_builditem_getoutbox(
        pBuildItem: Lib3MF_BuildItem,
        pOutbox: *mut sLib3MFBox,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Iterates to the next build item in the list."]
    #[doc = ""]
    #[doc = " @param[in] pBuildItemIterator - BuildItemIterator instance."]
    #[doc = " @param[out] pHasNext - Iterates to the next build item in the list."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_builditemiterator_movenext(
        pBuildItemIterator: Lib3MF_BuildItemIterator,
        pHasNext: *mut bool,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Iterates to the previous build item in the list."]
    #[doc = ""]
    #[doc = " @param[in] pBuildItemIterator - BuildItemIterator instance."]
    #[doc = " @param[out] pHasPrevious - Iterates to the previous build item in the list."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_builditemiterator_moveprevious(
        pBuildItemIterator: Lib3MF_BuildItemIterator,
        pHasPrevious: *mut bool,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the build item the iterator points at."]
    #[doc = ""]
    #[doc = " @param[in] pBuildItemIterator - BuildItemIterator instance."]
    #[doc = " @param[out] pBuildItem - returns the build item instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_builditemiterator_getcurrent(
        pBuildItemIterator: Lib3MF_BuildItemIterator,
        pBuildItem: *mut Lib3MF_BuildItem,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Creates a new build item iterator with the same build item list."]
    #[doc = ""]
    #[doc = " @param[in] pBuildItemIterator - BuildItemIterator instance."]
    #[doc = " @param[out] pOutBuildItemIterator - returns the cloned Iterator instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_builditemiterator_clone(
        pBuildItemIterator: Lib3MF_BuildItemIterator,
        pOutBuildItemIterator: *mut Lib3MF_BuildItemIterator,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the number of build items the iterator captures."]
    #[doc = ""]
    #[doc = " @param[in] pBuildItemIterator - BuildItemIterator instance."]
    #[doc = " @param[out] pCount - returns the number of build items the iterator captures."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_builditemiterator_count(
        pBuildItemIterator: Lib3MF_BuildItemIterator,
        pCount: *mut Lib3MF_uint64,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Set all vertices of a slice. All polygons will be cleared."]
    #[doc = ""]
    #[doc = " @param[in] pSlice - Slice instance."]
    #[doc = " @param[in] nVerticesBufferSize - Number of elements in buffer"]
    #[doc = " @param[in] pVerticesBuffer - Position2D buffer of contains the positions."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_slice_setvertices(
        pSlice: Lib3MF_Slice,
        nVerticesBufferSize: Lib3MF_uint64,
        pVerticesBuffer: *const sLib3MFPosition2D,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Get all vertices of a slice"]
    #[doc = ""]
    #[doc = " @param[in] pSlice - Slice instance."]
    #[doc = " @param[in] nVerticesBufferSize - Number of elements in buffer"]
    #[doc = " @param[out] pVerticesNeededCount - will be filled with the count of the written elements, or needed buffer size."]
    #[doc = " @param[out] pVerticesBuffer - Position2D  buffer of contains the positions."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_slice_getvertices(
        pSlice: Lib3MF_Slice,
        nVerticesBufferSize: Lib3MF_uint64,
        pVerticesNeededCount: *mut Lib3MF_uint64,
        pVerticesBuffer: *mut sLib3MFPosition2D,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Get the number of vertices in a slice"]
    #[doc = ""]
    #[doc = " @param[in] pSlice - Slice instance."]
    #[doc = " @param[out] pCount - the number of vertices in the slice"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_slice_getvertexcount(
        pSlice: Lib3MF_Slice,
        pCount: *mut Lib3MF_uint64,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Add a new polygon to this slice"]
    #[doc = ""]
    #[doc = " @param[in] pSlice - Slice instance."]
    #[doc = " @param[in] nIndicesBufferSize - Number of elements in buffer"]
    #[doc = " @param[in] pIndicesBuffer - uint32 buffer of the new indices of the new polygon"]
    #[doc = " @param[out] pIndex - the index of the new polygon"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_slice_addpolygon(
        pSlice: Lib3MF_Slice,
        nIndicesBufferSize: Lib3MF_uint64,
        pIndicesBuffer: *const Lib3MF_uint32,
        pIndex: *mut Lib3MF_uint64,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Get the number of polygons in the slice"]
    #[doc = ""]
    #[doc = " @param[in] pSlice - Slice instance."]
    #[doc = " @param[out] pCount - the number of polygons in the slice"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_slice_getpolygoncount(
        pSlice: Lib3MF_Slice,
        pCount: *mut Lib3MF_uint64,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Set all indices of a polygon"]
    #[doc = ""]
    #[doc = " @param[in] pSlice - Slice instance."]
    #[doc = " @param[in] nIndex - the index of the polygon to manipulate"]
    #[doc = " @param[in] nIndicesBufferSize - Number of elements in buffer"]
    #[doc = " @param[in] pIndicesBuffer - uint32 buffer of the new indices of the index-th polygon"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_slice_setpolygonindices(
        pSlice: Lib3MF_Slice,
        nIndex: Lib3MF_uint64,
        nIndicesBufferSize: Lib3MF_uint64,
        pIndicesBuffer: *const Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Get all vertices of a slice"]
    #[doc = ""]
    #[doc = " @param[in] pSlice - Slice instance."]
    #[doc = " @param[in] nIndex - the index of the polygon to manipulate"]
    #[doc = " @param[in] nIndicesBufferSize - Number of elements in buffer"]
    #[doc = " @param[out] pIndicesNeededCount - will be filled with the count of the written elements, or needed buffer size."]
    #[doc = " @param[out] pIndicesBuffer - uint32  buffer of the indices of the index-th polygon"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_slice_getpolygonindices(
        pSlice: Lib3MF_Slice,
        nIndex: Lib3MF_uint64,
        nIndicesBufferSize: Lib3MF_uint64,
        pIndicesNeededCount: *mut Lib3MF_uint64,
        pIndicesBuffer: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Get the number of vertices in a slice"]
    #[doc = ""]
    #[doc = " @param[in] pSlice - Slice instance."]
    #[doc = " @param[in] nIndex - the index of the polygon to manipulate"]
    #[doc = " @param[out] pCount - the number of indices of the index-th polygon"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_slice_getpolygonindexcount(
        pSlice: Lib3MF_Slice,
        nIndex: Lib3MF_uint64,
        pCount: *mut Lib3MF_uint64,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Get the upper Z-Coordinate of this slice."]
    #[doc = ""]
    #[doc = " @param[in] pSlice - Slice instance."]
    #[doc = " @param[out] pZTop - the upper Z-Coordinate of this slice"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_slice_getztop(pSlice: Lib3MF_Slice, pZTop: *mut Lib3MF_double) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Get the lower Z-Coordinate of the slice stack."]
    #[doc = ""]
    #[doc = " @param[in] pSliceStack - SliceStack instance."]
    #[doc = " @param[out] pZBottom - the lower Z-Coordinate the slice stack"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_slicestack_getbottomz(
        pSliceStack: Lib3MF_SliceStack,
        pZBottom: *mut Lib3MF_double,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the number of slices"]
    #[doc = ""]
    #[doc = " @param[in] pSliceStack - SliceStack instance."]
    #[doc = " @param[out] pCount - the number of slices"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_slicestack_getslicecount(
        pSliceStack: Lib3MF_SliceStack,
        pCount: *mut Lib3MF_uint64,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Query a slice from the slice stack"]
    #[doc = ""]
    #[doc = " @param[in] pSliceStack - SliceStack instance."]
    #[doc = " @param[in] nSliceIndex - the index of the slice"]
    #[doc = " @param[out] pTheSlice - the Slice instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_slicestack_getslice(
        pSliceStack: Lib3MF_SliceStack,
        nSliceIndex: Lib3MF_uint64,
        pTheSlice: *mut Lib3MF_Slice,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the number of slices"]
    #[doc = ""]
    #[doc = " @param[in] pSliceStack - SliceStack instance."]
    #[doc = " @param[in] dZTop - upper Z coordinate of the slice"]
    #[doc = " @param[out] pTheSlice - a new Slice instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_slicestack_addslice(
        pSliceStack: Lib3MF_SliceStack,
        dZTop: Lib3MF_double,
        pTheSlice: *mut Lib3MF_Slice,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the number of slice refs"]
    #[doc = ""]
    #[doc = " @param[in] pSliceStack - SliceStack instance."]
    #[doc = " @param[out] pCount - the number of slicereferences"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_slicestack_getslicerefcount(
        pSliceStack: Lib3MF_SliceStack,
        pCount: *mut Lib3MF_uint64,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Adds another existing slicestack as sliceref in this slicestack"]
    #[doc = ""]
    #[doc = " @param[in] pSliceStack - SliceStack instance."]
    #[doc = " @param[in] pTheSliceStack - the slicestack to use as sliceref"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_slicestack_addslicestackreference(
        pSliceStack: Lib3MF_SliceStack,
        pTheSliceStack: Lib3MF_SliceStack,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Adds another existing slicestack as sliceref in this slicestack"]
    #[doc = ""]
    #[doc = " @param[in] pSliceStack - SliceStack instance."]
    #[doc = " @param[in] nSliceRefIndex - the index of the slice ref"]
    #[doc = " @param[out] pTheSliceStack - the slicestack that is used as sliceref"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_slicestack_getslicestackreference(
        pSliceStack: Lib3MF_SliceStack,
        nSliceRefIndex: Lib3MF_uint64,
        pTheSliceStack: *mut Lib3MF_SliceStack,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Removes the indirection of slices via slice-refs, i.e. creates the slices of all slice refs of this SliceStack as actual slices of this SliceStack. All previously existing slices or slicerefs will be removed."]
    #[doc = ""]
    #[doc = " @param[in] pSliceStack - SliceStack instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_slicestack_collapseslicereferences(
        pSliceStack: Lib3MF_SliceStack,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the package path where this Slice should be stored. Input an empty string to reset the path"]
    #[doc = ""]
    #[doc = " @param[in] pSliceStack - SliceStack instance."]
    #[doc = " @param[in] pPath - the package path where this Slice should be stored"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_slicestack_setownpath(
        pSliceStack: Lib3MF_SliceStack,
        pPath: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Obtains the package path where this Slice should be stored. Returns an empty string if the slicestack is stored within the root model."]
    #[doc = ""]
    #[doc = " @param[in] pSliceStack - SliceStack instance."]
    #[doc = " @param[in] nPathBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pPathNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pPathBuffer -  buffer of the package path where this Slice will be stored, may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_slicestack_getownpath(
        pSliceStack: Lib3MF_SliceStack,
        nPathBufferSize: Lib3MF_uint32,
        pPathNeededChars: *mut Lib3MF_uint32,
        pPathBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Gets the consumerid"]
    #[doc = ""]
    #[doc = " @param[in] pConsumer - Consumer instance."]
    #[doc = " @param[in] nConsumerIDBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pConsumerIDNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pConsumerIDBuffer -  buffer of A unique identifier for the consumers, may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_consumer_getconsumerid(
        pConsumer: Lib3MF_Consumer,
        nConsumerIDBufferSize: Lib3MF_uint32,
        pConsumerIDNeededChars: *mut Lib3MF_uint32,
        pConsumerIDBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Getts the keyid"]
    #[doc = ""]
    #[doc = " @param[in] pConsumer - Consumer instance."]
    #[doc = " @param[in] nKeyIDBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pKeyIDNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pKeyIDBuffer -  buffer of The identifier for the key of this consumer, may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_consumer_getkeyid(
        pConsumer: Lib3MF_Consumer,
        nKeyIDBufferSize: Lib3MF_uint32,
        pKeyIDNeededChars: *mut Lib3MF_uint32,
        pKeyIDBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Gets the keyvalue associated with this consumer"]
    #[doc = ""]
    #[doc = " @param[in] pConsumer - Consumer instance."]
    #[doc = " @param[in] nKeyValueBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pKeyValueNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pKeyValueBuffer -  buffer of The public key, when available, of this consumer, may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_consumer_getkeyvalue(
        pConsumer: Lib3MF_Consumer,
        nKeyValueBufferSize: Lib3MF_uint32,
        pKeyValueNeededChars: *mut Lib3MF_uint32,
        pKeyValueBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Gets the consumer associated with this access right"]
    #[doc = ""]
    #[doc = " @param[in] pAccessRight - AccessRight instance."]
    #[doc = " @param[out] pConsumer - The consumer instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_accessright_getconsumer(
        pAccessRight: Lib3MF_AccessRight,
        pConsumer: *mut Lib3MF_Consumer,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Gets the associated encryption algorithm"]
    #[doc = ""]
    #[doc = " @param[in] pAccessRight - AccessRight instance."]
    #[doc = " @param[out] pAlgorithm - The algorithm used for the key in this accessright"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_accessright_getwrappingalgorithm(
        pAccessRight: Lib3MF_AccessRight,
        pAlgorithm: *mut eLib3MFWrappingAlgorithm,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Gets the associated mask generation function algorithm"]
    #[doc = ""]
    #[doc = " @param[in] pAccessRight - AccessRight instance."]
    #[doc = " @param[out] pAlgorithm - The MFG1 algorithm"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_accessright_getmgfalgorithm(
        pAccessRight: Lib3MF_AccessRight,
        pAlgorithm: *mut eLib3MFMgfAlgorithm,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Gets the digest method assoicated"]
    #[doc = ""]
    #[doc = " @param[in] pAccessRight - AccessRight instance."]
    #[doc = " @param[out] pAlgorithm - The digest method for this accessright"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_accessright_getdigestmethod(
        pAccessRight: Lib3MF_AccessRight,
        pAlgorithm: *mut eLib3MFDigestMethod,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the encryption method to be used in this encryption process"]
    #[doc = ""]
    #[doc = " @param[in] pContentEncryptionParams - ContentEncryptionParams instance."]
    #[doc = " @param[out] pAlgorithm -"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_contentencryptionparams_getencryptionalgorithm(
        pContentEncryptionParams: Lib3MF_ContentEncryptionParams,
        pAlgorithm: *mut eLib3MFEncryptionAlgorithm,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Gets the key for the resource associated"]
    #[doc = ""]
    #[doc = " @param[in] pContentEncryptionParams - ContentEncryptionParams instance."]
    #[doc = " @param[in] nByteDataBufferSize - Number of elements in buffer"]
    #[doc = " @param[out] pByteDataNeededCount - will be filled with the count of the written elements, or needed buffer size."]
    #[doc = " @param[out] pByteDataBuffer - uint8  buffer of Pointer to a buffer where to place the key."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_contentencryptionparams_getkey(
        pContentEncryptionParams: Lib3MF_ContentEncryptionParams,
        nByteDataBufferSize: Lib3MF_uint64,
        pByteDataNeededCount: *mut Lib3MF_uint64,
        pByteDataBuffer: *mut Lib3MF_uint8,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Gets the IV data"]
    #[doc = ""]
    #[doc = " @param[in] pContentEncryptionParams - ContentEncryptionParams instance."]
    #[doc = " @param[in] nByteDataBufferSize - Number of elements in buffer"]
    #[doc = " @param[out] pByteDataNeededCount - will be filled with the count of the written elements, or needed buffer size."]
    #[doc = " @param[out] pByteDataBuffer - uint8  buffer of Pointer to a buffer where to place the data."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_contentencryptionparams_getinitializationvector(
        pContentEncryptionParams: Lib3MF_ContentEncryptionParams,
        nByteDataBufferSize: Lib3MF_uint64,
        pByteDataNeededCount: *mut Lib3MF_uint64,
        pByteDataBuffer: *mut Lib3MF_uint8,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " A handler descriptor that uniquely identifies the context of the resource. Each resource will be assigned a different value"]
    #[doc = ""]
    #[doc = " @param[in] pContentEncryptionParams - ContentEncryptionParams instance."]
    #[doc = " @param[in] nByteDataBufferSize - Number of elements in buffer"]
    #[doc = " @param[out] pByteDataNeededCount - will be filled with the count of the written elements, or needed buffer size."]
    #[doc = " @param[out] pByteDataBuffer - uint8  buffer of Pointer to a buffer where to place the data."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_contentencryptionparams_getauthenticationtag(
        pContentEncryptionParams: Lib3MF_ContentEncryptionParams,
        nByteDataBufferSize: Lib3MF_uint64,
        pByteDataNeededCount: *mut Lib3MF_uint64,
        pByteDataBuffer: *mut Lib3MF_uint8,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the authentication tag"]
    #[doc = ""]
    #[doc = " @param[in] pContentEncryptionParams - ContentEncryptionParams instance."]
    #[doc = " @param[in] nByteDataBufferSize - Number of elements in buffer"]
    #[doc = " @param[in] pByteDataBuffer - uint8 buffer of The authentication tag size"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_contentencryptionparams_setauthenticationtag(
        pContentEncryptionParams: Lib3MF_ContentEncryptionParams,
        nByteDataBufferSize: Lib3MF_uint64,
        pByteDataBuffer: *const Lib3MF_uint8,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " A handler descriptor that uniquely identifies the context of the resource. Each resource will be assigned a different value"]
    #[doc = ""]
    #[doc = " @param[in] pContentEncryptionParams - ContentEncryptionParams instance."]
    #[doc = " @param[in] nByteDataBufferSize - Number of elements in buffer"]
    #[doc = " @param[out] pByteDataNeededCount - will be filled with the count of the written elements, or needed buffer size."]
    #[doc = " @param[out] pByteDataBuffer - uint8  buffer of Buffer where the data will be placed"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_contentencryptionparams_getadditionalauthenticationdata(
        pContentEncryptionParams: Lib3MF_ContentEncryptionParams,
        nByteDataBufferSize: Lib3MF_uint64,
        pByteDataNeededCount: *mut Lib3MF_uint64,
        pByteDataBuffer: *mut Lib3MF_uint8,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " A handler descriptor that uniquely identifies the context of the resource. Each resource will be assigned a different value"]
    #[doc = ""]
    #[doc = " @param[in] pContentEncryptionParams - ContentEncryptionParams instance."]
    #[doc = " @param[out] pDescriptor -"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_contentencryptionparams_getdescriptor(
        pContentEncryptionParams: Lib3MF_ContentEncryptionParams,
        pDescriptor: *mut Lib3MF_uint64,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Gets the resourcedatagroup keyuuid"]
    #[doc = ""]
    #[doc = " @param[in] pContentEncryptionParams - ContentEncryptionParams instance."]
    #[doc = " @param[in] nUUIDBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pUUIDNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pUUIDBuffer -  buffer of The resourcedatagroup keyuuid that may be use to reference an external key, may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_contentencryptionparams_getkeyuuid(
        pContentEncryptionParams: Lib3MF_ContentEncryptionParams,
        nUUIDBufferSize: Lib3MF_uint32,
        pUUIDNeededChars: *mut Lib3MF_uint32,
        pUUIDBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Gets the encrypted part path"]
    #[doc = ""]
    #[doc = " @param[in] pResourceData - ResourceData instance."]
    #[doc = " @param[out] pPath - The part path"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_resourcedata_getpath(
        pResourceData: Lib3MF_ResourceData,
        pPath: *mut Lib3MF_PackagePart,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Gets the encryption algorithm used to encrypt this ResourceData"]
    #[doc = ""]
    #[doc = " @param[in] pResourceData - ResourceData instance."]
    #[doc = " @param[out] pEncryptionAlgorithm - The encryption algorithm"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_resourcedata_getencryptionalgorithm(
        pResourceData: Lib3MF_ResourceData,
        pEncryptionAlgorithm: *mut eLib3MFEncryptionAlgorithm,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Tells whether this ResourceData is compressed or not"]
    #[doc = ""]
    #[doc = " @param[in] pResourceData - ResourceData instance."]
    #[doc = " @param[out] pCompression - The compression method"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_resourcedata_getcompression(
        pResourceData: Lib3MF_ResourceData,
        pCompression: *mut eLib3MFCompression,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Tells whether this ResourceData is compressed or not"]
    #[doc = ""]
    #[doc = " @param[in] pResourceData - ResourceData instance."]
    #[doc = " @param[in] nByteDataBufferSize - Number of elements in buffer"]
    #[doc = " @param[out] pByteDataNeededCount - will be filled with the count of the written elements, or needed buffer size."]
    #[doc = " @param[out] pByteDataBuffer - uint8  buffer of The compression method"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_resourcedata_getadditionalauthenticationdata(
        pResourceData: Lib3MF_ResourceData,
        nByteDataBufferSize: Lib3MF_uint64,
        pByteDataNeededCount: *mut Lib3MF_uint64,
        pByteDataBuffer: *mut Lib3MF_uint8,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the resourcedatagroup keyuuid"]
    #[doc = ""]
    #[doc = " @param[in] pResourceDataGroup - ResourceDataGroup instance."]
    #[doc = " @param[in] nUUIDBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pUUIDNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pUUIDBuffer -  buffer of The new resourcedatagroup keyuuid., may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_resourcedatagroup_getkeyuuid(
        pResourceDataGroup: Lib3MF_ResourceDataGroup,
        nUUIDBufferSize: Lib3MF_uint32,
        pUUIDNeededChars: *mut Lib3MF_uint32,
        pUUIDBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Add accessright to resourcedatagroup element"]
    #[doc = ""]
    #[doc = " @param[in] pResourceDataGroup - ResourceDataGroup instance."]
    #[doc = " @param[in] pConsumer - The Consumer reference"]
    #[doc = " @param[in] eWrappingAlgorithm - The key wrapping algorithm to be used"]
    #[doc = " @param[in] eMgfAlgorithm - The mask generation function to be used"]
    #[doc = " @param[in] eDigestMethod - The digest mechanism to be used"]
    #[doc = " @param[out] pTheAccessRight - The acess right instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_resourcedatagroup_addaccessright(
        pResourceDataGroup: Lib3MF_ResourceDataGroup,
        pConsumer: Lib3MF_Consumer,
        eWrappingAlgorithm: eLib3MFWrappingAlgorithm,
        eMgfAlgorithm: eLib3MFMgfAlgorithm,
        eDigestMethod: eLib3MFDigestMethod,
        pTheAccessRight: *mut Lib3MF_AccessRight,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Finds the AccessRight associated with a Consumer"]
    #[doc = ""]
    #[doc = " @param[in] pResourceDataGroup - ResourceDataGroup instance."]
    #[doc = " @param[in] pConsumer - The Consumer instance"]
    #[doc = " @param[out] pTheAccessRight - The AcessRight instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_resourcedatagroup_findaccessrightbyconsumer(
        pResourceDataGroup: Lib3MF_ResourceDataGroup,
        pConsumer: Lib3MF_Consumer,
        pTheAccessRight: *mut Lib3MF_AccessRight,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Removes access from a Consumer on this resource data group"]
    #[doc = ""]
    #[doc = " @param[in] pResourceDataGroup - ResourceDataGroup instance."]
    #[doc = " @param[in] pConsumer - The Consumer instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_resourcedatagroup_removeaccessright(
        pResourceDataGroup: Lib3MF_ResourceDataGroup,
        pConsumer: Lib3MF_Consumer,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Adds a consumer to the keystore"]
    #[doc = ""]
    #[doc = " @param[in] pKeyStore - KeyStore instance."]
    #[doc = " @param[in] pConsumerID - A unique identifier for the consumer"]
    #[doc = " @param[in] pKeyID - The id of the key of the consumer"]
    #[doc = " @param[in] pKeyValue - The public key for this consumer in PEM format"]
    #[doc = " @param[out] pConsumer - The consumer instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_keystore_addconsumer(
        pKeyStore: Lib3MF_KeyStore,
        pConsumerID: *const ::std::os::raw::c_char,
        pKeyID: *const ::std::os::raw::c_char,
        pKeyValue: *const ::std::os::raw::c_char,
        pConsumer: *mut Lib3MF_Consumer,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Gets the number of consumers in the keystore"]
    #[doc = ""]
    #[doc = " @param[in] pKeyStore - KeyStore instance."]
    #[doc = " @param[out] pCount - The consumer count"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_keystore_getconsumercount(
        pKeyStore: Lib3MF_KeyStore,
        pCount: *mut Lib3MF_uint64,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Get a consumer from the keystore"]
    #[doc = ""]
    #[doc = " @param[in] pKeyStore - KeyStore instance."]
    #[doc = " @param[in] nConsumerIndex - The index of the consumer"]
    #[doc = " @param[out] pConsumer - The consumer instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_keystore_getconsumer(
        pKeyStore: Lib3MF_KeyStore,
        nConsumerIndex: Lib3MF_uint64,
        pConsumer: *mut Lib3MF_Consumer,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Removes a consumer from the keystore"]
    #[doc = ""]
    #[doc = " @param[in] pKeyStore - KeyStore instance."]
    #[doc = " @param[in] pConsumer - The consumer instance to remove"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_keystore_removeconsumer(
        pKeyStore: Lib3MF_KeyStore,
        pConsumer: Lib3MF_Consumer,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Finds a consumer by ID"]
    #[doc = ""]
    #[doc = " @param[in] pKeyStore - KeyStore instance."]
    #[doc = " @param[in] pConsumerID - The ID of the consumer"]
    #[doc = " @param[out] pConsumer - The consumer instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_keystore_findconsumer(
        pKeyStore: Lib3MF_KeyStore,
        pConsumerID: *const ::std::os::raw::c_char,
        pConsumer: *mut Lib3MF_Consumer,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Gets the number of resource data group in the keysore"]
    #[doc = ""]
    #[doc = " @param[in] pKeyStore - KeyStore instance."]
    #[doc = " @param[out] pCount - The number of resource data available"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_keystore_getresourcedatagroupcount(
        pKeyStore: Lib3MF_KeyStore,
        pCount: *mut Lib3MF_uint64,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Adds a resource data group into the keystore."]
    #[doc = ""]
    #[doc = " @param[in] pKeyStore - KeyStore instance."]
    #[doc = " @param[out] pResourceDataGroup - The resource data group instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_keystore_addresourcedatagroup(
        pKeyStore: Lib3MF_KeyStore,
        pResourceDataGroup: *mut Lib3MF_ResourceDataGroup,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Gets a resource data group"]
    #[doc = ""]
    #[doc = " @param[in] pKeyStore - KeyStore instance."]
    #[doc = " @param[in] nResourceDataIndex - The index of the resource data"]
    #[doc = " @param[out] pResourceDataGroup - The resource data group instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_keystore_getresourcedatagroup(
        pKeyStore: Lib3MF_KeyStore,
        nResourceDataIndex: Lib3MF_uint64,
        pResourceDataGroup: *mut Lib3MF_ResourceDataGroup,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Removes a resource data group"]
    #[doc = ""]
    #[doc = " @param[in] pKeyStore - KeyStore instance."]
    #[doc = " @param[in] pResourceDataGroup - The resource data group instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_keystore_removeresourcedatagroup(
        pKeyStore: Lib3MF_KeyStore,
        pResourceDataGroup: Lib3MF_ResourceDataGroup,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Finds a resource data group that contains a particular resourcedata"]
    #[doc = ""]
    #[doc = " @param[in] pKeyStore - KeyStore instance."]
    #[doc = " @param[in] pPartPath - The target path for the resourcedata hold by the resource data group"]
    #[doc = " @param[out] pResourceDataGroup - The data resource instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_keystore_findresourcedatagroup(
        pKeyStore: Lib3MF_KeyStore,
        pPartPath: Lib3MF_PackagePart,
        pResourceDataGroup: *mut Lib3MF_ResourceDataGroup,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Add resourcedata to resourcedatagroup element"]
    #[doc = ""]
    #[doc = " @param[in] pKeyStore - KeyStore instance."]
    #[doc = " @param[in] pResourceDataGroup - The resource data group where to add this resource data"]
    #[doc = " @param[in] pPartPath - The path of the part to be encrypted"]
    #[doc = " @param[in] eAlgorithm - The encryption algorithm to be used to encrypt this resource"]
    #[doc = " @param[in] eCompression - Whether compression should be used prior to encryption"]
    #[doc = " @param[in] nAdditionalAuthenticationDataBufferSize - Number of elements in buffer"]
    #[doc = " @param[in] pAdditionalAuthenticationDataBuffer - uint8 buffer of Additional data to be encrypted along the contents for better security"]
    #[doc = " @param[out] pResourceData - The data resource instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_keystore_addresourcedata(
        pKeyStore: Lib3MF_KeyStore,
        pResourceDataGroup: Lib3MF_ResourceDataGroup,
        pPartPath: Lib3MF_PackagePart,
        eAlgorithm: eLib3MFEncryptionAlgorithm,
        eCompression: eLib3MFCompression,
        nAdditionalAuthenticationDataBufferSize: Lib3MF_uint64,
        pAdditionalAuthenticationDataBuffer: *const Lib3MF_uint8,
        pResourceData: *mut Lib3MF_ResourceData,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Removes a resource data"]
    #[doc = ""]
    #[doc = " @param[in] pKeyStore - KeyStore instance."]
    #[doc = " @param[in] pResourceData - The resource data to be removed"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_keystore_removeresourcedata(
        pKeyStore: Lib3MF_KeyStore,
        pResourceData: Lib3MF_ResourceData,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Finds a resource data on this resource group"]
    #[doc = ""]
    #[doc = " @param[in] pKeyStore - KeyStore instance."]
    #[doc = " @param[in] pResourcePath - The target path for the resourcedata"]
    #[doc = " @param[out] pResourceData - The resource data instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_keystore_findresourcedata(
        pKeyStore: Lib3MF_KeyStore,
        pResourcePath: Lib3MF_PackagePart,
        pResourceData: *mut Lib3MF_ResourceData,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Gets the number of resource data in the keysore"]
    #[doc = ""]
    #[doc = " @param[in] pKeyStore - KeyStore instance."]
    #[doc = " @param[out] pCount - The number of resource data available"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_keystore_getresourcedatacount(
        pKeyStore: Lib3MF_KeyStore,
        pCount: *mut Lib3MF_uint64,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Gets a resource data"]
    #[doc = ""]
    #[doc = " @param[in] pKeyStore - KeyStore instance."]
    #[doc = " @param[in] nResourceDataIndex - The index of the resource data"]
    #[doc = " @param[out] pResourceData - The data resource instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_keystore_getresourcedata(
        pKeyStore: Lib3MF_KeyStore,
        nResourceDataIndex: Lib3MF_uint64,
        pResourceData: *mut Lib3MF_ResourceData,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Gets the keystore UUID"]
    #[doc = ""]
    #[doc = " @param[in] pKeyStore - KeyStore instance."]
    #[doc = " @param[out] pHasUUID - flag whether the keystore has a UUID"]
    #[doc = " @param[in] nUUIDBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pUUIDNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pUUIDBuffer -  buffer of returns the keystore uuid., may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_keystore_getuuid(
        pKeyStore: Lib3MF_KeyStore,
        pHasUUID: *mut bool,
        nUUIDBufferSize: Lib3MF_uint32,
        pUUIDNeededChars: *mut Lib3MF_uint32,
        pUUIDBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the keystore UUID"]
    #[doc = ""]
    #[doc = " @param[in] pKeyStore - KeyStore instance."]
    #[doc = " @param[in] pUUID - The new keystore uuid."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_keystore_setuuid(
        pKeyStore: Lib3MF_KeyStore,
        pUUID: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the PackagePart within the OPC package that holds the root model."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pRootModelPart - the PackagePart within the OPC package that holds the model-file"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_rootmodelpart(
        pModel: Lib3MF_Model,
        pRootModelPart: *mut Lib3MF_PackagePart,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns a new PackagePart for use within the OPC package."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] pAbsolutePath - the absolute Path (physical location) within the OPC package"]
    #[doc = " @param[out] pModelPart - the new PackagePart within the OPC package"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_findorcreatepackagepart(
        pModel: Lib3MF_Model,
        pAbsolutePath: *const ::std::os::raw::c_char,
        pModelPart: *mut Lib3MF_PackagePart,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " sets the units of a model."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] eUnit - Unit enum value for the model unit"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_setunit(pModel: Lib3MF_Model, eUnit: eLib3MFModelUnit) -> Lib3MFResult;
}
extern "C" {
    #[doc = " returns the units of a model."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pUnit - Unit enum value for the model unit"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getunit(pModel: Lib3MF_Model, pUnit: *mut eLib3MFModelUnit)
        -> Lib3MFResult;
}
extern "C" {
    #[doc = " retrieves the language of a model"]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] nLanguageBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pLanguageNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pLanguageBuffer -  buffer of language identifier, may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getlanguage(
        pModel: Lib3MF_Model,
        nLanguageBufferSize: Lib3MF_uint32,
        pLanguageNeededChars: *mut Lib3MF_uint32,
        pLanguageBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " sets the language of a model"]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] pLanguage - language identifier"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_setlanguage(
        pModel: Lib3MF_Model,
        pLanguage: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " creates a model writer instance for a specific file type"]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] pWriterClass -  string identifier for the file type"]
    #[doc = " @param[out] pWriterInstance -  string identifier for the file type"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_querywriter(
        pModel: Lib3MF_Model,
        pWriterClass: *const ::std::os::raw::c_char,
        pWriterInstance: *mut Lib3MF_Writer,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " creates a model reader instance for a specific file type"]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] pReaderClass -  string identifier for the file type"]
    #[doc = " @param[out] pReaderInstance -  string identifier for the file type"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_queryreader(
        pModel: Lib3MF_Model,
        pReaderClass: *const ::std::os::raw::c_char,
        pReaderInstance: *mut Lib3MF_Reader,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " finds a model texture by its UniqueResourceID"]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] nUniqueResourceID - UniqueResourceID"]
    #[doc = " @param[out] pTextureInstance - returns the texture2d instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_gettexture2dbyid(
        pModel: Lib3MF_Model,
        nUniqueResourceID: Lib3MF_uint32,
        pTextureInstance: *mut Lib3MF_Texture2D,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " returns a Property's type"]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] nUniqueResourceID - Resource ID of the Property to Query"]
    #[doc = " @param[out] pThePropertyType - returns a Property's type"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getpropertytypebyid(
        pModel: Lib3MF_Model,
        nUniqueResourceID: Lib3MF_uint32,
        pThePropertyType: *mut eLib3MFPropertyType,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " finds a model base material group by its UniqueResourceID"]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] nUniqueResourceID - UniqueResourceID"]
    #[doc = " @param[out] pBaseMaterialGroupInstance - returns the BaseMaterialGroup instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getbasematerialgroupbyid(
        pModel: Lib3MF_Model,
        nUniqueResourceID: Lib3MF_uint32,
        pBaseMaterialGroupInstance: *mut Lib3MF_BaseMaterialGroup,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " finds a model texture2d group by its UniqueResourceID"]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] nUniqueResourceID - UniqueResourceID"]
    #[doc = " @param[out] pTexture2DGroupInstance - returns the Texture2DGroup instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_gettexture2dgroupbyid(
        pModel: Lib3MF_Model,
        nUniqueResourceID: Lib3MF_uint32,
        pTexture2DGroupInstance: *mut Lib3MF_Texture2DGroup,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " finds a model CompositeMaterials by its UniqueResourceID"]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] nUniqueResourceID - UniqueResourceID"]
    #[doc = " @param[out] pCompositeMaterialsInstance - returns the CompositeMaterials instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getcompositematerialsbyid(
        pModel: Lib3MF_Model,
        nUniqueResourceID: Lib3MF_uint32,
        pCompositeMaterialsInstance: *mut Lib3MF_CompositeMaterials,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " finds a model MultiPropertyGroup by its UniqueResourceID"]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] nUniqueResourceID - UniqueResourceID"]
    #[doc = " @param[out] pMultiPropertyGroupInstance - returns the MultiPropertyGroup instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getmultipropertygroupbyid(
        pModel: Lib3MF_Model,
        nUniqueResourceID: Lib3MF_uint32,
        pMultiPropertyGroupInstance: *mut Lib3MF_MultiPropertyGroup,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " finds a mesh object by its UniqueResourceID"]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] nUniqueResourceID - UniqueResourceID"]
    #[doc = " @param[out] pMeshObjectInstance - returns the mesh object instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getmeshobjectbyid(
        pModel: Lib3MF_Model,
        nUniqueResourceID: Lib3MF_uint32,
        pMeshObjectInstance: *mut Lib3MF_MeshObject,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " finds a components object by its UniqueResourceID"]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] nUniqueResourceID - UniqueResourceID"]
    #[doc = " @param[out] pComponentsObjectInstance - returns the components object instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getcomponentsobjectbyid(
        pModel: Lib3MF_Model,
        nUniqueResourceID: Lib3MF_uint32,
        pComponentsObjectInstance: *mut Lib3MF_ComponentsObject,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " finds a model color group by its UniqueResourceID"]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] nUniqueResourceID - UniqueResourceID"]
    #[doc = " @param[out] pColorGroupInstance - returns the ColorGroup instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getcolorgroupbyid(
        pModel: Lib3MF_Model,
        nUniqueResourceID: Lib3MF_uint32,
        pColorGroupInstance: *mut Lib3MF_ColorGroup,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " finds a model slicestack by its UniqueResourceID"]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] nUniqueResourceID - UniqueResourceID"]
    #[doc = " @param[out] pSliceStacInstance - returns the slicestack instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getslicestackbyid(
        pModel: Lib3MF_Model,
        nUniqueResourceID: Lib3MF_uint32,
        pSliceStacInstance: *mut Lib3MF_SliceStack,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " returns, whether a build has a UUID and, if true, the build's UUID"]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pHasUUID - flag whether the build has a UUID"]
    #[doc = " @param[in] nUUIDBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pUUIDNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pUUIDBuffer -  buffer of the UUID as string of the form 'xxxxxxxx-xxxx-xxxx-xxxxxxxxxxxxxxxx', may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getbuilduuid(
        pModel: Lib3MF_Model,
        pHasUUID: *mut bool,
        nUUIDBufferSize: Lib3MF_uint32,
        pUUIDNeededChars: *mut Lib3MF_uint32,
        pUUIDBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " sets the build's UUID"]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] pUUID - the UUID as string of the form 'xxxxxxxx-xxxx-xxxx-xxxxxxxxxxxxxxxx'"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_setbuilduuid(
        pModel: Lib3MF_Model,
        pUUID: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " creates a build item iterator instance with all build items."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pBuildItemIterator - returns the iterator instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getbuilditems(
        pModel: Lib3MF_Model,
        pBuildItemIterator: *mut Lib3MF_BuildItemIterator,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the outbox of a Model"]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pOutbox - Outbox of this Model"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getoutbox(pModel: Lib3MF_Model, pOutbox: *mut sLib3MFBox) -> Lib3MFResult;
}
extern "C" {
    #[doc = " creates a resource iterator instance with all resources."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pResourceIterator - returns the iterator instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getresources(
        pModel: Lib3MF_Model,
        pResourceIterator: *mut Lib3MF_ResourceIterator,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " creates a resource iterator instance with all object resources."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pResourceIterator - returns the iterator instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getobjects(
        pModel: Lib3MF_Model,
        pResourceIterator: *mut Lib3MF_ObjectIterator,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " creates a resource iterator instance with all mesh object resources."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pResourceIterator - returns the iterator instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getmeshobjects(
        pModel: Lib3MF_Model,
        pResourceIterator: *mut Lib3MF_MeshObjectIterator,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " creates a resource iterator instance with all components object resources."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pResourceIterator - returns the iterator instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getcomponentsobjects(
        pModel: Lib3MF_Model,
        pResourceIterator: *mut Lib3MF_ComponentsObjectIterator,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " creates a Texture2DIterator instance with all texture2d resources."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pResourceIterator - returns the iterator instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_gettexture2ds(
        pModel: Lib3MF_Model,
        pResourceIterator: *mut Lib3MF_Texture2DIterator,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " creates a BaseMaterialGroupIterator instance with all base material resources."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pResourceIterator - returns the iterator instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getbasematerialgroups(
        pModel: Lib3MF_Model,
        pResourceIterator: *mut Lib3MF_BaseMaterialGroupIterator,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " creates a ColorGroupIterator instance with all ColorGroup resources."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pResourceIterator - returns the iterator instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getcolorgroups(
        pModel: Lib3MF_Model,
        pResourceIterator: *mut Lib3MF_ColorGroupIterator,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " creates a Texture2DGroupIterator instance with all base material resources."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pResourceIterator - returns the iterator instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_gettexture2dgroups(
        pModel: Lib3MF_Model,
        pResourceIterator: *mut Lib3MF_Texture2DGroupIterator,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " creates a CompositeMaterialsIterator instance with all CompositeMaterials resources."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pResourceIterator - returns the iterator instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getcompositematerials(
        pModel: Lib3MF_Model,
        pResourceIterator: *mut Lib3MF_CompositeMaterialsIterator,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " creates a MultiPropertyGroupsIterator instance with all MultiPropertyGroup resources."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pResourceIterator - returns the iterator instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getmultipropertygroups(
        pModel: Lib3MF_Model,
        pResourceIterator: *mut Lib3MF_MultiPropertyGroupIterator,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " creates a resource iterator instance with all slice stack resources."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pResourceIterator - returns the iterator instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getslicestacks(
        pModel: Lib3MF_Model,
        pResourceIterator: *mut Lib3MF_SliceStackIterator,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Merges all components and objects which are referenced by a build item into a mesh. The memory is duplicated and a new model is created."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pMergedModelInstance - returns the merged model instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_mergetomodel(
        pModel: Lib3MF_Model,
        pMergedModelInstance: *mut Lib3MF_Model,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " adds an empty mesh object to the model."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pMeshObjectInstance -  returns the mesh object instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_addmeshobject(
        pModel: Lib3MF_Model,
        pMeshObjectInstance: *mut Lib3MF_MeshObject,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " adds an empty component object to the model."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pComponentsObjectInstance -  returns the components object instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_addcomponentsobject(
        pModel: Lib3MF_Model,
        pComponentsObjectInstance: *mut Lib3MF_ComponentsObject,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " creates a new model slicestack by its id"]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] dZBottom - Bottom Z value of the slicestack"]
    #[doc = " @param[out] pSliceStackInstance - returns the new slicestack instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_addslicestack(
        pModel: Lib3MF_Model,
        dZBottom: Lib3MF_double,
        pSliceStackInstance: *mut Lib3MF_SliceStack,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " adds a texture2d resource to the model. Its path is given by that of an existing attachment."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] pTextureAttachment - attachment containing the image data."]
    #[doc = " @param[out] pTexture2DInstance - returns the new texture instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_addtexture2dfromattachment(
        pModel: Lib3MF_Model,
        pTextureAttachment: Lib3MF_Attachment,
        pTexture2DInstance: *mut Lib3MF_Texture2D,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " adds an empty BaseMaterialGroup resource to the model."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pBaseMaterialGroupInstance - returns the new base material instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_addbasematerialgroup(
        pModel: Lib3MF_Model,
        pBaseMaterialGroupInstance: *mut Lib3MF_BaseMaterialGroup,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " adds an empty ColorGroup resource to the model."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pColorGroupInstance - returns the new ColorGroup instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_addcolorgroup(
        pModel: Lib3MF_Model,
        pColorGroupInstance: *mut Lib3MF_ColorGroup,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " adds an empty Texture2DGroup resource to the model."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] pTexture2DInstance - The texture2D instance of the created Texture2DGroup."]
    #[doc = " @param[out] pTexture2DGroupInstance - returns the new Texture2DGroup instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_addtexture2dgroup(
        pModel: Lib3MF_Model,
        pTexture2DInstance: Lib3MF_Texture2D,
        pTexture2DGroupInstance: *mut Lib3MF_Texture2DGroup,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " adds an empty CompositeMaterials resource to the model."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] pBaseMaterialGroupInstance - The BaseMaterialGroup instance of the created CompositeMaterials."]
    #[doc = " @param[out] pCompositeMaterialsInstance - returns the new CompositeMaterials instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_addcompositematerials(
        pModel: Lib3MF_Model,
        pBaseMaterialGroupInstance: Lib3MF_BaseMaterialGroup,
        pCompositeMaterialsInstance: *mut Lib3MF_CompositeMaterials,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " adds an empty MultiPropertyGroup resource to the model."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pMultiPropertyGroupInstance - returns the new MultiPropertyGroup instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_addmultipropertygroup(
        pModel: Lib3MF_Model,
        pMultiPropertyGroupInstance: *mut Lib3MF_MultiPropertyGroup,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " adds a build item to the model."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] pObject - Object instance."]
    #[doc = " @param[in] pTransform - Transformation matrix."]
    #[doc = " @param[out] pBuildItemInstance - returns the build item instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_addbuilditem(
        pModel: Lib3MF_Model,
        pObject: Lib3MF_Object,
        pTransform: *const sLib3MFTransform,
        pBuildItemInstance: *mut Lib3MF_BuildItem,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " removes a build item from the model"]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] pBuildItemInstance - Build item to remove."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_removebuilditem(
        pModel: Lib3MF_Model,
        pBuildItemInstance: Lib3MF_BuildItem,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the metadata of the model as MetaDataGroup"]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pTheMetaDataGroup - returns an Instance of the metadatagroup of the model"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getmetadatagroup(
        pModel: Lib3MF_Model,
        pTheMetaDataGroup: *mut Lib3MF_MetaDataGroup,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " adds an attachment stream to the model. The OPC part will be related to the model stream with a certain relationship type."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] pURI - Path of the attachment"]
    #[doc = " @param[in] pRelationShipType - Relationship type of the attachment"]
    #[doc = " @param[out] pAttachmentInstance - Instance of the attachment object"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_addattachment(
        pModel: Lib3MF_Model,
        pURI: *const ::std::os::raw::c_char,
        pRelationShipType: *const ::std::os::raw::c_char,
        pAttachmentInstance: *mut Lib3MF_Attachment,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Removes attachment from the model."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] pAttachmentInstance - Attachment instance to remove"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_removeattachment(
        pModel: Lib3MF_Model,
        pAttachmentInstance: Lib3MF_Attachment,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " retrieves an attachment stream object from the model.."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] nIndex - Index of the attachment stream"]
    #[doc = " @param[out] pAttachmentInstance - Instance of the attachment object"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getattachment(
        pModel: Lib3MF_Model,
        nIndex: Lib3MF_uint32,
        pAttachmentInstance: *mut Lib3MF_Attachment,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " retrieves an attachment stream object from the model."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] pURI - Path URI in the package"]
    #[doc = " @param[out] pAttachmentInstance - Instance of the attachment object"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_findattachment(
        pModel: Lib3MF_Model,
        pURI: *const ::std::os::raw::c_char,
        pAttachmentInstance: *mut Lib3MF_Attachment,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " retrieves the number of attachments of the model."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pAttachmentCount - Returns the number of attachments."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getattachmentcount(
        pModel: Lib3MF_Model,
        pAttachmentCount: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieve whether the OPC package contains a package thumbnail."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pHasThumbnail - returns whether the OPC package contains a package thumbnail"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_haspackagethumbnailattachment(
        pModel: Lib3MF_Model,
        pHasThumbnail: *mut bool,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Create a new or the existing package thumbnail for the OPC package."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pAttachment - Instance of a new or the existing thumbnailattachment object."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_createpackagethumbnailattachment(
        pModel: Lib3MF_Model,
        pAttachment: *mut Lib3MF_Attachment,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Get the attachment to the OPC package containing the package thumbnail."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pAttachment - Instance of the thumbnailattachment object or NULL."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getpackagethumbnailattachment(
        pModel: Lib3MF_Model,
        pAttachment: *mut Lib3MF_Attachment,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Remove the attachment to the OPC package containing the package thumbnail."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_removepackagethumbnailattachment(pModel: Lib3MF_Model) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Adds a new Content Type to the model."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] pExtension - File Extension"]
    #[doc = " @param[in] pContentType - Content Type Identifier"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_addcustomcontenttype(
        pModel: Lib3MF_Model,
        pExtension: *const ::std::os::raw::c_char,
        pContentType: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Removes a custom Content Type from the model (UTF8 version)."]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] pExtension - File Extension"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_removecustomcontenttype(
        pModel: Lib3MF_Model,
        pExtension: *const ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the random number generator callback for use in the library"]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[in] pTheCallback - The callback used to generate random numbers"]
    #[doc = " @param[in] pUserData - Userdata to be passed to the callback function"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_setrandomnumbercallback(
        pModel: Lib3MF_Model,
        pTheCallback: Lib3MFRandomNumberCallback,
        pUserData: Lib3MF_pvoid,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Gets the keystore associated with this model"]
    #[doc = ""]
    #[doc = " @param[in] pModel - Model instance."]
    #[doc = " @param[out] pKeyStore - The package keystore"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_model_getkeystore(
        pModel: Lib3MF_Model,
        pKeyStore: *mut Lib3MF_KeyStore,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " retrieves the binary version of this library."]
    #[doc = ""]
    #[doc = " @param[out] pMajor - returns the major version of this library"]
    #[doc = " @param[out] pMinor - returns the minor version of this library"]
    #[doc = " @param[out] pMicro - returns the micro version of this library"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_getlibraryversion(
        pMajor: *mut Lib3MF_uint32,
        pMinor: *mut Lib3MF_uint32,
        pMicro: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " retrieves prerelease information of this library."]
    #[doc = ""]
    #[doc = " @param[out] pHasPrereleaseInfo - Does the library provide prerelease version?"]
    #[doc = " @param[in] nPrereleaseInfoBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pPrereleaseInfoNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pPrereleaseInfoBuffer -  buffer of retrieves prerelease information of this library., may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_getprereleaseinformation(
        pHasPrereleaseInfo: *mut bool,
        nPrereleaseInfoBufferSize: Lib3MF_uint32,
        pPrereleaseInfoNeededChars: *mut Lib3MF_uint32,
        pPrereleaseInfoBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " retrieves build information of this library."]
    #[doc = ""]
    #[doc = " @param[out] pHasBuildInfo - Does the library provide build version?"]
    #[doc = " @param[in] nBuildInformationBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pBuildInformationNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pBuildInformationBuffer -  buffer of retrieves build information of this library., may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_getbuildinformation(
        pHasBuildInfo: *mut bool,
        nBuildInformationBufferSize: Lib3MF_uint32,
        pBuildInformationNeededChars: *mut Lib3MF_uint32,
        pBuildInformationBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " retrieves whether a specification is supported, and if so, which version."]
    #[doc = ""]
    #[doc = " @param[in] pSpecificationURL - URL of extension to check"]
    #[doc = " @param[out] pIsSupported - returns whether this specification is supported"]
    #[doc = " @param[out] pMajor - returns the major version of the extension (if IsSupported)"]
    #[doc = " @param[out] pMinor - returns the minor version of the extension (if IsSupported)"]
    #[doc = " @param[out] pMicro - returns the micro version of the extension (if IsSupported)"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_getspecificationversion(
        pSpecificationURL: *const ::std::os::raw::c_char,
        pIsSupported: *mut bool,
        pMajor: *mut Lib3MF_uint32,
        pMinor: *mut Lib3MF_uint32,
        pMicro: *mut Lib3MF_uint32,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " creates an empty model instance."]
    #[doc = ""]
    #[doc = " @param[out] pModel - returns an empty model instance"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_createmodel(pModel: *mut Lib3MF_Model) -> Lib3MFResult;
}
extern "C" {
    #[doc = " releases shared ownership of an object instance"]
    #[doc = ""]
    #[doc = " @param[in] pInstance - the object instance to release"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_release(pInstance: Lib3MF_Base) -> Lib3MFResult;
}
extern "C" {
    #[doc = " acquires shared ownership of an object instance"]
    #[doc = ""]
    #[doc = " @param[in] pInstance - the object instance to acquire"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_acquire(pInstance: Lib3MF_Base) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Sets the journal file path"]
    #[doc = ""]
    #[doc = " @param[in] pJournalPath - File name of the journal file"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_setjournal(pJournalPath: *const ::std::os::raw::c_char) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Retrieves the last error string of an instance"]
    #[doc = ""]
    #[doc = " @param[in] pInstance - Object where the error occured."]
    #[doc = " @param[in] nLastErrorStringBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pLastErrorStringNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pLastErrorStringBuffer -  buffer of Last Error String, may be NULL"]
    #[doc = " @param[out] pHasLastError - Returns if the instance has a last error."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_getlasterror(
        pInstance: Lib3MF_Base,
        nLastErrorStringBufferSize: Lib3MF_uint32,
        pLastErrorStringNeededChars: *mut Lib3MF_uint32,
        pLastErrorStringBuffer: *mut ::std::os::raw::c_char,
        pHasLastError: *mut bool,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Returns the address of the SymbolLookupMethod"]
    #[doc = ""]
    #[doc = " @param[out] pSymbolLookupMethod - Address of the SymbolAddressMethod"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_getsymbollookupmethod(pSymbolLookupMethod: *mut Lib3MF_pvoid) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Return an English text for a progress identifier.|Note: this is the only function you can call from your callback function."]
    #[doc = ""]
    #[doc = " @param[in] eTheProgressIdentifier - the progress identifier that is passed to the callback function"]
    #[doc = " @param[in] nProgressMessageBufferSize - size of the buffer (including trailing 0)"]
    #[doc = " @param[out] pProgressMessageNeededChars - will be filled with the count of the written bytes, or needed buffer size."]
    #[doc = " @param[out] pProgressMessageBuffer -  buffer of English text for the progress identifier, may be NULL"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_retrieveprogressmessage(
        eTheProgressIdentifier: eLib3MFProgressIdentifier,
        nProgressMessageBufferSize: Lib3MF_uint32,
        pProgressMessageNeededChars: *mut Lib3MF_uint32,
        pProgressMessageBuffer: *mut ::std::os::raw::c_char,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Creates a Color from uint8 RGBA values"]
    #[doc = ""]
    #[doc = " @param[in] nRed - Red value of color (0-255)"]
    #[doc = " @param[in] nGreen - Green value of color (0-255)"]
    #[doc = " @param[in] nBlue - Blue value of color (0-255)"]
    #[doc = " @param[in] nAlpha - Alpha value of color (0-255)"]
    #[doc = " @param[out] pTheColor - Assembled color"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_rgbatocolor(
        nRed: Lib3MF_uint8,
        nGreen: Lib3MF_uint8,
        nBlue: Lib3MF_uint8,
        nAlpha: Lib3MF_uint8,
        pTheColor: *mut sLib3MFColor,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Creates a Color from uint8 RGBA values"]
    #[doc = ""]
    #[doc = " @param[in] fRed - Red value of color (0-1)"]
    #[doc = " @param[in] fGreen - Green value of color (0-1)"]
    #[doc = " @param[in] fBlue - Blue value of color (0-1)"]
    #[doc = " @param[in] fAlpha - Alpha value of color (0-1)"]
    #[doc = " @param[out] pTheColor - Assembled color"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_floatrgbatocolor(
        fRed: Lib3MF_single,
        fGreen: Lib3MF_single,
        fBlue: Lib3MF_single,
        fAlpha: Lib3MF_single,
        pTheColor: *mut sLib3MFColor,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Calculates uint8-RGBA-values from a Color"]
    #[doc = ""]
    #[doc = " @param[in] pTheColor - Color to handle"]
    #[doc = " @param[out] pRed - Red value of color (0-255)"]
    #[doc = " @param[out] pGreen - Green value of color (0-255)"]
    #[doc = " @param[out] pBlue - Blue value of color (0-255)"]
    #[doc = " @param[out] pAlpha - Alpha value of color (0-255)"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_colortorgba(
        pTheColor: *const sLib3MFColor,
        pRed: *mut Lib3MF_uint8,
        pGreen: *mut Lib3MF_uint8,
        pBlue: *mut Lib3MF_uint8,
        pAlpha: *mut Lib3MF_uint8,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Calculates float-RGBA-values from a Color"]
    #[doc = ""]
    #[doc = " @param[in] pTheColor - Color to handle"]
    #[doc = " @param[out] pRed - Red value of color (0-1)"]
    #[doc = " @param[out] pGreen - Green value of color (0-1)"]
    #[doc = " @param[out] pBlue - Blue value of color (0-1)"]
    #[doc = " @param[out] pAlpha - Alpha value of color (0-1)"]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_colortofloatrgba(
        pTheColor: *const sLib3MFColor,
        pRed: *mut Lib3MF_single,
        pGreen: *mut Lib3MF_single,
        pBlue: *mut Lib3MF_single,
        pAlpha: *mut Lib3MF_single,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Creates an identity transform"]
    #[doc = ""]
    #[doc = " @param[out] pTransform - Transformation matrix."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_getidentitytransform(pTransform: *mut sLib3MFTransform) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Creates a uniform scale transform"]
    #[doc = ""]
    #[doc = " @param[in] fFactor - Factor in X, Y and Z"]
    #[doc = " @param[out] pTransform - Transformation matrix."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_getuniformscaletransform(
        fFactor: Lib3MF_single,
        pTransform: *mut sLib3MFTransform,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Creates a scale transform"]
    #[doc = ""]
    #[doc = " @param[in] fFactorX - Factor in X"]
    #[doc = " @param[in] fFactorY - Factor in Y"]
    #[doc = " @param[in] fFactorZ - Factor in Z"]
    #[doc = " @param[out] pTransform - Transformation matrix."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_getscaletransform(
        fFactorX: Lib3MF_single,
        fFactorY: Lib3MF_single,
        fFactorZ: Lib3MF_single,
        pTransform: *mut sLib3MFTransform,
    ) -> Lib3MFResult;
}
extern "C" {
    #[doc = " Creates an translation transform"]
    #[doc = ""]
    #[doc = " @param[in] fVectorX - Translation in X"]
    #[doc = " @param[in] fVectorY - Translation in Y"]
    #[doc = " @param[in] fVectorZ - Translation in Z"]
    #[doc = " @param[out] pTransform - Transformation matrix."]
    #[doc = " @return error code or 0 (success)"]
    pub fn lib3mf_gettranslationtransform(
        fVectorX: Lib3MF_single,
        fVectorY: Lib3MF_single,
        fVectorZ: Lib3MF_single,
        pTransform: *mut sLib3MFTransform,
    ) -> Lib3MFResult;
}
